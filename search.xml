<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Node.js+express+MySQL仿美团注册登录绑定第三方登录前后端的实现]]></title>
      <url>%2F2017%2F01%2F23%2FNode.js%2Bexpress%2BMySQL%E4%BB%BF%E7%BE%8E%E5%9B%A2%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E7%BB%91%E5%AE%9A%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[准备在开始做这个前，希望你已经配置好的Node,express和MySQL的开发环境。也可以参考参考文章 开发环境的配置 新建项目参考Mac下express的安装和新建项目 mysql模块在package.json文件的dependencies下加入下面的代码“mysql”: “latest”,最终的效果：然后cd到项目所在的目录，在终端中执行npm install,项目就会配置mysql模块。 新建数据库配置文件在项目目录下新建一个db目录，在目录项新建两个文件DBConfig.js和usersql.js效果如下：其中的DBConfig.js是数据库的配置文件，只要代码如下：123456789101112131415161718192021module.exports =&#123; mysql: &#123; user: 'root', password: '123456', database: 'userinfo' &#125;&#125;;``` 就是数据库的用户名，密码和数据库名。如果你的数据库和代码不再一个电脑就需要数据库的地址。&lt;code&gt;usersql.js&lt;/code&gt;就是实现后台业务所需要的mysql的操作语句``` javascriptvar UserSQL = &#123; insert:'INSERT INTO user(username,password,date,type,openid) VALUES(?,?,?,?,?)', bangding:'UPDATE user SET type = ?,openid = ? WHERE username = ? AND password = ? ', queryAll:'SELECT * FROM user', getUserByOpenid:'SELECT * FROM user WHERE openid = ? ', getUserByInfo:'SELECT * FROM user WHERE username = ? AND password = ? ', deleteUserByInfo:'DELETE FROM user WHERE username = ? AND password = ? ',&#125;;module.exports = UserSQL; 实现后台业务 业务流程在实现业务之前还是先看看流程，我在用了美团app后自己画了一个美团登录和绑定第三方的简单流程。其中注册流程也简化了。关于注册我也简化了，就是输入账号和密码就可以注册。 代码实现我的具体业务是写在users.js前提是已经建立了对应的数据库和表。首先要引入mysql依赖 123456// 导入MySQL模块var dbConfig = require('../db/DBConfig');var User = require('../db/usersql');var mysql = require('mysql'); // 引入mysql依赖var client = mysql.createConnection(dbConfig.mysql); // 建立连接 首先看看注册流程：1.用户输入用户名和密码，点击注册按钮，发送注册请求；2.后台根据用户提交的用户名和密码去数据区查找有没有对应的用户， 没有，注册成功，把新用户插入数据库 同时记录注册时间 有，注册失败，用户已经存在123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 注册接口router.all('/user/register', function(req, res, next)&#123; if (req.method == "POST") &#123; var param = req.body; &#125; else&#123; var param = req.query || req.params; &#125; client.query(User.getUserByInfo,[param.username,param.password],function (err, results)&#123; if (err)&#123; throw err &#125;else&#123; // 数据库不存在 就注册成功 if (results.length == 0) &#123; // 把新用户插入数据库 client.query(User.insert,[param.username,param.password,getDataStr(),'',''],function (err, results) &#123; if(err)&#123; throw err &#125;else&#123; res.end(JSON.stringify(&#123;status:'100',msg:'注册成功!'&#125;)); &#125; &#125;) &#125; else&#123; // 数据库存在就注册失败 res.end(JSON.stringify(&#123;status:'101',msg:'该用户名已经被注册'&#125;)); &#125; &#125; &#125;)&#125;);``` - 登录流程登录就是更具用户提交过来的用户名和密码去数据区比较，用户名和密码都相同就登录，否则就提示用户名或密码错误。当然这是简单的，还要做的就是是否存在这个用户。``` javascript// 登录接口router.all('/user/login', function(req, res, next)&#123; if (req.method == "POST") &#123; var param = req.body; &#125; else&#123; var param = req.query || req.params; &#125; client.query(User.getUserByInfo,[param.username,param.password],function (err, results)&#123; if (err)&#123; throw err &#125;else&#123; // 数据库存在 if (results.length == 0) &#123; res.end(JSON.stringify(&#123;status:'102',msg:'用户名或密码错误'&#125;)); &#125; else&#123; if (results[0].username == param.username &amp;&amp; results[0].password == param.password) &#123; res.end(JSON.stringify(&#123;status:'100',msg:'登录成功'&#125;)); &#125; &#125; &#125; &#125;)&#125;); 第三方登录第三方登录有这么两步：根据用户的第三方用户唯一标识，这里统称openid去数据库查找 数据库的某个用户的openid和这个相等就返回注册成功 数据库没有就，跳转到绑定页面，做绑定用户名的操作这里，为了前台能够判断用户是否绑定了，我给了一个flag字段。123456789101112131415161718192021// 第三方登陆接口router.all('/user/thirdlogin', function(req, res, next)&#123; if (req.method == "POST") &#123; var param = req.body; &#125; else&#123; var param = req.query || req.params; &#125; console.log(param.openid); client.query(User.getUserByOpenid,[param.openid],function (err, results)&#123; if (err)&#123; throw err &#125;else&#123; // 数据库不存在 就跳转绑定 flag=1 需要绑定 flag=2 // 不需要绑定 if (results.length == 0) &#123; res.end(JSON.stringify(&#123;status:'100',msg:'操作成功',flag:'1'&#125;)); &#125; else&#123; // 数据库存在就登录成功 res.end(JSON.stringify(&#123;status:'100',msg:'登录成功',flag:'2'&#125;)); &#125; &#125; &#125;)&#125;); 绑定用户这个就没什么了。就是更新用户的数据 12345678910111213141516171819202122// 绑定接口router.all('/user/bangding', function(req, res, next)&#123; if (req.method == "POST") &#123; var param = req.body; &#125; else&#123; var param = req.query || req.params; &#125; client.query(User.getUserByInfo,[param.username,param.password],function (err, results)&#123; if (err)&#123; throw err &#125;else&#123; // 更新用户信息 client.query(User.bangding,[param.type,param.openid,param.username,param.password],function (err, results) &#123; if(err)&#123; throw err &#125;else&#123; res.end(JSON.stringify(&#123;status:'100',msg:'绑定成功!'&#125;)); &#125; &#125;) &#125; &#125;)&#125;); 测试以上的流程基本是最简单的了。测试可以在浏览器测试，根据接口输入对应的参数即可。我是自己写了一个简单的测试app。我是事先在数据库插入了一些数据，下面测试我会用到的。app效果： 总结以前一直都是写iOS的app或是H5的app。这次自己独自写前后台。算是一下小小的突破。前后台一起写的时候，发现前后台，需要很多的配合。以前只是接口不对了就找后台修改。这次就是自己修改了。这需要很多的配合。就像月初做那个物流管理的app。后台人员我就不吐槽了。我都想找他把数据库的地址用户名和密码要过来，我自己写后台算了。要学习的还有很多，遇见问题不要怕，仔细的看报错信息，自己先静下心来思考，看文档。不懂再上网搜索。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js+express的接口适配get和post并输出json]]></title>
      <url>%2F2017%2F01%2F19%2FNode.js%2Bexpress%E7%9A%84%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8Dget%E5%92%8Cpost%E5%B9%B6%E8%BE%93%E5%87%BAjson%2F</url>
      <content type="text"><![CDATA[在上一篇Node.js+express的get和post输出json例如post请求：12345678910111213141516171819202122232425var dataSuccess = &#123; status: '100', msg: '登录成功', data: &#123; userId: '20170113', userName: 'hgdqstudio', blog: 'http://hgdqstudio.online' &#125;&#125;;var dataError = &#123; status: '99', msg: '用户名或密码错误'&#125;;// 登录接口router.post('/login',function (req, res, next) &#123; // 打印post请求的数据内容 console.log(req.body); console.log(req.body.username); console.log(req.body.password); if (req.body.username == "hgdqstudio" &amp;&amp; req.body.password == "123456") &#123; res.end(JSON.stringify(dataSuccess)); &#125; else &#123; res.end(JSON.stringify(dataError)); &#125;&#125;); 但是这种接口，只能适应post这一种请求，如果我们希望后台给的接口支持post和get。显然上一篇中提到了的router.get和router.post都不能满足需求。在express中支持的方式是很多的，具体可以看文档。我们就需要改造了。1234567891011121314151617// 登录接口router.all('/login',function (req, res, next) &#123; console.log(req.method);// 打印请求方式 if (req.method == "POST") &#123; var param = req.body; &#125; else&#123; var param = req.query || req.params; &#125; console.log(param); console.log(param.username); console.log(param.password); if (param.username == "hgdqstudio" &amp;&amp; param.password == "123456") &#123; res.end(JSON.stringify(dataSuccess)); &#125; else &#123; res.end(JSON.stringify(dataError)); &#125;&#125;); 改造就很获取请求方式，饭后获取请求里面的参数：post请求获取的参数是在body里面，get请求获取的参数是在query里面，后面的params暂未发现有什么作用。然后我们就可以在postman里面测试或是用Node.js.express的get和post输出json提到的mui.ajax来测试【我使用的十MUI框架写的手机端界面】。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下MySQL的安装和配置]]></title>
      <url>%2F2017%2F01%2F19%2FMac%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[一、下载MySQL官网下载页面点击后进入如下页面按图操作即可，接下来： 二、安装和配置安装按照步骤来即可。但是要记住最后的初始密码。最后我们在电脑的系统偏好设置里面可以看见安装的MySQL默认MySQL是启动的。在打开之前我们需要在终端中配置一下。1234567891011121314151617PATH=&quot;$PATH&quot;:/usr/local/mysql/binmysql -u root -p#输入密码#Terminal显示#Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 10Server version: 5.7.12Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt;SET PASSWORD = PASSWORD(&apos;new password&apos;); 操作完上面的就可以正常使用MySQL。详细可以参考《Mac OS系统安装Mysql》。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js+express的get和post输出json]]></title>
      <url>%2F2017%2F01%2F19%2FNode.js%2Bexpress%E7%9A%84get%E5%92%8Cpost%E8%BE%93%E5%87%BAjson%2F</url>
      <content type="text"><![CDATA[在上一篇Mac下express的安装和新建项目已经按章好了我们的环境，项目也新建好了。在浏览器中也看见的输出效果：在项目的目录中views这个目录我展开了，但是并没有说明。这个就是我们的视图显示的文件。中心看看index.ejs我们就会知道了。1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 原来是一个ejs模板，加载的样式文件是/stylesheets/style.css这个css文件。所以呢，我们知道这些就就可以尽情的按照自己的需求修改了。但是这个只是一个页面，这个页面和数据所在的/routes/index.js是分开的，这就需要路由了。也就是我为什么用express的原因。在Mac下安装Node.js、测试、输出json我们安装的Node.js可以在我新建的test.js文件，运行后可以正常输出json数据。但是如果有很多接口那不是我们都要写在这个js文件里面。很显然这不现实。这里express的路由的作用就出来了。在app.js文件里面代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var express = require('express');var path = require('path');var favicon = require('serve-favicon');var cookieParser = require('cookie-parser');// post请求会用到var bodyParser = require('body-parser');var index = require('./routes/index');var users = require('./routes/users');var app = express();// view engine setupapp.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');// uncomment after placing your favicon in /public//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());app.use(cookieParser());app.use(express.static(path.join(__dirname, 'public')));// 设置请求头// application/json 接口返回json数据// charset=utf-8 解决json数据中中文乱码app.use("*", function(request, response, next) &#123; response.writeHead(200, &#123; "Content-Type": "application/json;charset=utf-8" &#125;); next();&#125;);// 路由app.use('/', index);app.use('/', users);// 404 错误var errorData_404 = &#123; status: '404', msg: 'Not Found!',&#125;;app.use(function(req, res, next) &#123; var err = new Error('Not Found'); err.status = 404; res.end(JSON.stringify(errorData_404));&#125;);// 500 var errorData_500 = &#123; status: '500', msg: 'Not Found!',&#125;;app.use(function(err, req, res, next) &#123; errorData_500.msg = err.message; res.end(JSON.stringify(errorData_500));&#125;);module.exports = app; 一、get请求在/routes/index.js文件中插入如下代码这个里面做的是一个get请求1234567891011121314151617181920// 增加url 依赖var urllib = require('url');// 初始数据var data = &#123; status: '100', msg: '操作成功', data: &#123; userId: '123456', userName: 'hgdqstudio', blog: 'http://hgdqstudio.online' &#125;&#125;;// get请求router.get('/index', function (req, res, next) &#123; var params = urllib.parse(req.url, true); var query2 = params.query; // 打印get请求中的接口参数 console.log(query2); res.end(JSON.stringify(data));&#125;); 我们在vim里面cd到项目的目录然后npm start就可以在浏览器中输入：1http://localhost:3000/index 效果如图：至此get请求就搞完了。我们在这个接口里面拼接参数，可以在终端里面打印的。 二、post请求在/routes/users.js12345678910111213141516171819202122232425var dataSuccess = &#123; status: '100', msg: '登录成功', data: &#123; userId: '20170113', userName: 'hgdqstudio', blog: 'http://hgdqstudio.online' &#125;&#125;;var dataError = &#123; status: '99', msg: '用户名或密码错误'&#125;;// 登录接口router.post('/login',function (req, res, next) &#123; // 打印post请求的数据内容 console.log(req.body); console.log(req.body.username); console.log(req.body.password); if (req.body.username == "hgdqstudio" &amp;&amp; req.body.password == "123456") &#123; res.end(JSON.stringify(dataSuccess)); &#125; else &#123; res.end(JSON.stringify(dataError)); &#125;&#125;); 做的是一个模拟的登录接口。可以自己写一个ajax测试123456789101112131415mui.ajax("http://127.0.0.1:3000/login",&#123; data: &#123; username: 'hgdqstudio', 'password': 123456 //password不加引号显示像一个关键字，所以就嘿嘿…… &#125;, dataType: 'json', type: 'post', timeout: 10000, success: function(data)&#123; console.log(data.msg); &#125;, error: function(xhr, type, errerThrown)&#123; &#125;&#125;); 也可以使用Postman测试：在app.js文件里面多了一个body-parser的依赖。这个是express里面的一个中间组件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(十五)iOS平台5+插件开发]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E5%8D%81%E4%BA%94)iOS%E5%B9%B3%E5%8F%B05%2B%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[在开发iOS平台5+插件前，希望你已经会了iOS离线打包的集成。如果不会也没事，这里也会说明的。iOS平台5+插件开发,在开发之前还是看看。这里说点题外话：前些时有位网友加我QQ问我,前台需要做微信第三方登录，后台需要怎么配合？怎么搞？需要绑定的是什么？他说他在网上没找到怎么做。遇见这些问题我不知道该说什么，我是做前台的。我们以前做第三方登录都是获取一个第三方账号的唯一ID给后台，比如微信的openid。那么哪个字段是唯一的，这些看官方的文档就可以找打。我也是从小白过来的，我根据我之前的经验我就在网上找了两天文章给他，然后告诉他去看官方文档。言归正传。 一、技术架构HTML5+ 基座扩展采用三层结构，JS层、PluginBridge层和Native层。 三层功能分别是：JS层： 在Webview页面调用，触发Native层代码，获取执行结果。PluginBridge层： 将JS层请求进行处理，触发Native层扩展插件代码。Native层： 插件扩展的平台原生代码，负责执行业务逻辑并执行结果返回到请求页面。这都都是官方文档里面的。我们需要知道的是有这么3层。其中的中间层是不需要我们做的。 二、扩展插件工作流程由于我做的事异步扩展，所以我只截图异步的。异步方法的执行不会阻塞当前JS的运行，方法的执行结果会通过回调的方式返回给调用者。 三、具体集成流程1.首先下载iOS平台的SDK最新IOS平台SDK下载解压出来后我们看见的时这样的：里面的word文档《IOS平台5+SDK技术白皮书.docx》会告诉你每个文件是做什么的。2.打开HBuilder-Hello这个Xcode工程。文档看完后，先运行一下这个工程。其实是可以正常编译的。3.项目目录介绍关于目录的具体介绍，可以看iOS离线打包这篇文章。4.使用HBulder新建一个移动app项目使用HBulder新建一个移动app项目，不会的可以看这里HBuilder webApp开发(一)新建项目。5.新建一个hgdqplugin.js的js文件6.修改移动app项目目录各式如下：最终我的修改如下：注意看目录结构。有些文件是我没有的所以就不需要。7.替换Xcode项目里面的HelloH5项目替换之后效果如下：8.修改HGDQTest目录里面的manifest.json里面的应用名和appid为HGDQTest。效果如下：这个我们可以下Hbuilder新建移动app项目的时候就修改，也可以在Xcode里面修改。我是在Xcode里面修改的。9.修改Xcode项目里的control.xml文件123456&lt;HBuilder version="1.9.9.28340"&gt; &lt;!--应用节点--&gt; &lt;apps&gt; &lt;app appid='HGDQTest' appver='1.0.0'/&gt; &lt;/apps&gt;&lt;/HBuilder&gt; 主要是appid，这里一定要和你的项目名字一样。接下来就可以运行项目了。为了看见效果，我在index.html文件里面写一些内容。运行后的效果如下：其实有了这些，加上上面看的官方的文本，这些就可本地打包了。 四、iOS插件开发我做的是，H5的页面跳转到原生的页面去，同时H5的页面和原生的页面之间互相传值。这个时候我们刚才新建的hgdqplugin.js文件就有用处了。在下面的操作之前，请先看完这篇文档：IOS平台第三方插件开发指导1.编写hgdqplugin.js里面的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546document.addEventListener("plusready", function() &#123; var _BARCODE = 'HGDQPlugin', B = window.plus.bridge; var HGDQPlugin = &#123; hgdqGotoNative: function(params, successCallback, errorCallback) &#123; var success = typeof successCallback !== 'function' ? null : function(args) &#123; successCallback(args); &#125;, fail = typeof errorCallback !== 'function' ? null : function(code) &#123; errorCallback(code); &#125;; callbackID = B.callbackId(success, fail); //通知执行异步方法 return B.exec(_BARCODE, "hgdqGotoNative", [callbackID, params]); &#125; &#125;; window.plus.HGDQPlugin = HGDQPlugin;&#125;, true);``` 我使用的是异步的方式。2.新建一个&lt;code style="padding: 2px 4px; color: #c7254e;background-color: #f9f2f4;border-radius: 4px;"&gt;HGDQPlugin&lt;/code&gt;的类，继承自&lt;code style="padding: 2px 4px; color: #c7254e;background-color: #f9f2f4;border-radius: 4px;"&gt;PGPlugin&lt;/code&gt;。![效果4](http://o9059a64b.bkt.clouddn.com/pgplugin.png)3.新建一个原生的界面&lt;code style="padding: 2px 4px; color: #c7254e;background-color: #f9f2f4;border-radius: 4px;"&gt;HGDQViewController&lt;/code&gt;，继承自&lt;code style="padding: 2px 4px; color: #c7254e;background-color: #f9f2f4;border-radius: 4px;"&gt;UIViewController&lt;/code&gt;现在的效果：![效果5](http://o9059a64b.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-18%20%E4%B8%8A%E5%8D%889.55.06.png)4.编写&lt;code style="padding: 2px 4px; color: #c7254e;background-color: #f9f2f4;border-radius: 4px;"&gt;HGDQViewController&lt;/code&gt;里面的代码就是一个按钮，这里就不再上图了。5.编写HGDQPlugin里面的代码``` Objective-C- (void)hgdqGotoNative:(PGMethod *)commands&#123; if (commands) &#123; NSString *cbid = [commands.arguments objectAtIndex:0]; NSString *revInfo = [commands.arguments objectAtIndex:1]; NSLog(@"userInfo = %@",revInfo); NSLog(@"cbid = %@",cbid); // 跳转到原生界面 HGDQViewController *hgdqVC = [[HGDQViewController alloc] init]; hgdqVC.dic = (NSDictionary *)revInfo; UIViewController *rootVC = [UIApplication sharedApplication].keyWindow.rootViewController; [rootVC presentViewController:hgdqVC animated:YES completion:nil]; // 原生界面向H5界面传值 NSDictionary *cDice = @&#123;@"name":@"http://hgdqstudio.online"&#125;; PDRPluginResult *result = [PDRPluginResult resultWithStatus:PDRCommandStatusOK messageAsDictionary:cDice]; [self toCallback:cbid withReslut:[result toJSONString]]; &#125;&#125; 然后把这个方法在头文件中声明一下。6.配置feature.plist7.在manifest.json加入权限123"HGDQPlugin":&#123; "description": "原生界面" &#125; 还有一点需要特别注意的就是manifest.json文件里面不能有注释。8.修改AppDelegate.m文件123456789101112131415- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; PDRCore* core = [PDRCore Instance]; //添加一个自定义插件 NSError *error = nil; NSString *JSPath = [[NSBundle mainBundle] pathForResource:@&quot;Pandora/apps/HGDQtest/www/js/AppDelegate&quot; ofType:@&quot;js&quot;]; // 这里的路径就是新建的AppDelegate.js文件的路径 NSString *logPluginJS = [NSString stringWithContentsOfFile:JSPath encoding:NSUTF8StringEncoding error:&amp;error]; [core regPluginWithName:@&quot;HGDQPlugin&quot; impClassName:@&quot;HGDQPlugin&quot; type:PDRExendPluginTypeFrame javaScript:logPluginJS]; // HGDQPlugin 就是新建的HGDQPlugin类的名字 return YES;&#125; 9.在index.html文件里面引入我们新建的hgdqplugin.js这个文件。10.添加按钮点击事件：123456789101112// 按钮点击事件document.querySelector('button').addEventListener('tap',function()&#123; // H5界面向原生界面传值 var params = &#123; name: "H5+ iOS平台插件开发", des: "http://hudqstudio.online", title: "返回" &#125;; plus.HGDQPlugin.hgdqGotoNative(params,function(data)&#123; reciveData.innerText = data.name; &#125;, function(data) &#123;&#125;);&#125;) 最后就是运行看效果了。 五、代码下载最后文比较长，比乱，图比较多。还不如代码来的实在。下载地址：请点我!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(十四)二维码扫描]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E5%8D%81%E5%9B%9B)%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%2F</url>
      <content type="text"><![CDATA[好久没有写《HBuilder webApp App开发》这个专栏了。这周的这两天暂时比骄没事，就对着官方文档barcode写了这个二维码扫描的Demo。以前做原生开发的时候，关于二维码扫描、识别图片中的二维码、和二维码生成都写过。具体可以看这些：《【iOS】AVFoundation架构下的原生二维码和条形码扫描》《【iOS】CoreImage原生二维码生成（一）》《【iOS】CoreImage原生二维码生成（二）一个方法生成带logo的二维码》在做Ｈ5的APP的时候，之前也写过《HBuilder webApp开发(十一)二维码生成》。原生开发和H5的开发都写过，发现还是H5的开发代码量会少一点，但是这个就看项目是原生开发还是H5开发了。总体感觉做二维码扫描和生成不难，认真看文档，理清思路，修改官方Demo,然后测试就好了。直接上代码，注释都在代码里面了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;body &gt; &lt;header class="mui-bar mui-bar-nav white"&gt; &lt;a class="mui-action-back mui-icon mui-icon-left-nav mui-pull-left"&gt;&lt;/a&gt; &lt;h1 class="mui-title"&gt;二维码扫描&lt;/h1&gt; &lt;/header&gt; &lt;div class="mui-content"&gt; &lt;button id="startScan" class="mui-btn mui-btn-success"&gt;开始扫描&lt;/button&gt; &lt;button id="cancelScan" class="mui-btn mui-btn-success"&gt;取消扫描&lt;/button&gt; &lt;button id="setFlash" class="mui-btn mui-btn-success"&gt;开启/关闭闪光灯&lt;/button&gt; &lt;div id= "bcid"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; mui.init(&#123; swipeBack:true //启用右滑关闭功能 &#125;); var scan = null; var isOpen = false; // 闪光灯是否开始标志 true:闪光灯已经开启 false:闪光灯关闭 // 条码识别成功事件 function onmarked( type, result ) &#123; var text = '未知: '; switch(type)&#123; case plus.barcode.QR: text = 'QR: '; // 二维码 break; case plus.barcode.EAN13: text = 'EAN13: '; break; case plus.barcode.EAN8: text = 'EAN8: '; break; &#125; alert( text+result ); &#125; // 创建扫描控件 function startRecognize() &#123; scan = new plus.barcode.Barcode('bcid'); scan.onmarked = onmarked; &#125; // 开始扫描 document.getElementById("startScan").addEventListener('tap',function()&#123; startRecognize(); scan.start(); &#125;) // 取消扫描 document.getElementById("cancelScan").addEventListener('tap',function()&#123; startRecognize(); scan.cancel(); &#125;) // 开启和关闭闪光灯 document.getElementById("setFlash").addEventListener('tap',function()&#123; startRecognize(); isOpen = !isOpen; if(isOpen)&#123; scan.setFlash(true); &#125;else&#123; scan.setFlash(false); &#125; &#125;)&lt;/script&gt; 效果图什么的就不上了，和前面提到的文章中的效果图基本一样。代码下载地址：请点击我！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(十三)微信-支付宝支付]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E5%8D%81%E4%B8%89)%E5%BE%AE%E4%BF%A1-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%2F</url>
      <content type="text"><![CDATA[在公司的项目中，使用了微信支付，支付实际项目里面的支付流程和之前做原生app的时候是一样的。只是现在使用H5开发。Hbuild是支持微信支付和支付宝支付的，虽说项目里只使用了微信支付，但是还是要研究一下支付宝支付的。以前写《【iOS】集成支付宝支付/银联支付/微信支付》那个时候遇见了很多坑，但是趟过去了，后面就好了。 一、看文档在接触一个新的事物时，先看看官方的文档。《支付插件配置》这是配置支付环境。《payment》这是HTML5+的支付部分接口文档。《支付错误码》对着错误码可以方便我们调试。《微信、支付宝支付那点事》这个是网友写的经验，值得看看。 二、而我我就是站在这些巨人的肩膀上面做了微信支付和支付宝支付，当然后台部分不是我做的。下面的代码也只能是Demo. 三、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Hello MUI&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;!--标准mui.css--&gt; &lt;link rel="stylesheet" href="../css/mui.min.css"&gt; &lt;link rel="stylesheet" href="../css/mui.css" /&gt; &lt;link rel="stylesheet" href="../css/app.css" /&gt; &lt;!--App自定义的css--&gt; &lt;style type="text/css"&gt; .head &#123; margin-top: 10px; &#125; .head img&#123; width: 120px; height: 120px; margin-left: calc(50% - 60px); &#125; .top &#123; margin-top: 40px; &#125; .weixin &#123; width: 60px; height: 60px; margin-left: calc(50% - 30px); background: url(../images/icon-weixin.png); &#125; .zhifubao &#123; width: 60px; height: 60px; margin-left: calc(50% - 30px); background: url(../images/alipay.jpg); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header class="mui-bar mui-bar-nav white"&gt; &lt;a class="mui-action-back mui-icon mui-icon-left-nav mui-pull-left"&gt;&lt;/a&gt; &lt;h1 class="mui-title"&gt;第三方登录&lt;/h1&gt; &lt;/header&gt; &lt;div class="mui-content"&gt; &lt;div class="top" id="testLogin"&gt; &lt;input type="button" class="weixin" id="weixin"/&gt; &lt;input type="button" class="zhifubao" id="zhifubao"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="../js/mui.min.js"&gt;&lt;/script&gt; &lt;script src="../js/mui.zoom.js"&gt; &lt;/script&gt; &lt;script src="../js/mui.previewimage.js"&gt;&lt;/script&gt; &lt;script src="../js/tools.js" &gt;&lt;/script&gt; &lt;script&gt; var wxChannel = null; // 微信支付 var aliChannel = null; // 支付宝支付 var channel = null; mui.init(&#123; swipeBack:true //启用右滑关闭功能 &#125;); mui.plusReady(function() &#123; // 获取支付通道 plus.payment.getChannels(function(channels)&#123; aliChannel=channels[0]; wxChannel=channels[1]; &#125;,function(e)&#123; alert("获取支付通道失败："+e.message); &#125;); &#125;) document.getElementById('weixin').addEventListener('tap',function() &#123; console.log("微信"); pay('wxpay'); &#125;) document.getElementById('zhifubao').addEventListener('tap',function() &#123; console.log("zhifubao"); pay('alipay'); &#125;) var ALIPAYSERVER='http://demo.dcloud.net.cn/helloh5/payment/alipay.php?total='; var WXPAYSERVER='http://demo.dcloud.net.cn/helloh5/payment/wxpay.php?total='; // 2. 发起支付请求 function pay(id)&#123; // 从服务器请求支付订单 var PAYSERVER=''; if(id=='alipay')&#123; PAYSERVER=ALIPAYSERVER; channel = aliChannel; &#125;else if(id=='wxpay')&#123; PAYSERVER=WXPAYSERVER; channel = wxChannel; &#125;else&#123; plus.nativeUI.alert("不支持此支付通道！",null,"捐赠"); return; &#125; var xhr=new XMLHttpRequest(); xhr.onreadystatechange=function()&#123; switch(xhr.readyState)&#123; case 4: if(xhr.status==200)&#123; plus.payment.request(channel,xhr.responseText,function(result)&#123; plus.nativeUI.alert("支付成功！",function()&#123; back(); &#125;); &#125;,function(error)&#123; plus.nativeUI.alert("支付失败：" + error.code); &#125;); &#125;else&#123; alert("获取订单信息失败！"); &#125; break; default: break; &#125; &#125; xhr.open('GET',PAYSERVER); xhr.send(); &#125; &lt;/script&gt;&lt;/html&gt; 有不明白的可以直接多看看文档，代码的注释官方文档都有了。 四、最后原生和H5的也做了一些东西了，感觉这些涉及到第三方的东西，一定要多看文档和Demo，疏通流程就好了。代码下载地址：请点击我！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(十二)二维码生成]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E5%8D%81%E4%BA%8C)%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%2F</url>
      <content type="text"><![CDATA[在MUI框架里,MUI帮我们把二维码的扫描（摄像头扫描和图片中扫描）都做好了，但是二维码的生成却没有做。官方文档barcode。在iOS元里面，以前也写过二维码扫描的《【iOS】AVFoundation架构下的原生二维码和条形码扫描》二维码生成和读取图片中的二维码《【iOS】一个方法读取图片中的二维码信息》总体上来说实现起来不难。在H5里面更加简单。 一、包含jquery文件使用之前需要先引用连个js文件jquery-1.8.3.min.jsjquery.qrcode.min.js12&lt;script type="text/javascript" src="../js/jquery-1.8.3.min.js" &gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/jquery.qrcode.min.js" &gt;&lt;/script&gt; 二、新建一个div元素1&lt;div class="qrcode" style="background: white;height: 256px; width: 256px;"&gt;&lt;/div&gt; 三、一个方法生成二维码1$('.qrcode').qrcode(qrcodeUrl); 其中qrcodeUrl是一个url地址。 四、效果图 ##最后代码下载地址：请点击我！欢迎给星星。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(十一)在线差异化升级]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E5%8D%81%E4%B8%80)%E5%9C%A8%E7%BA%BF%E5%B7%AE%E5%BC%82%E5%8C%96%E5%8D%87%E7%BA%A7%2F</url>
      <content type="text"><![CDATA[从4月份公司确定使用H5开发app，主要考虑了两点：1.一套代码可以生成安卓和iOS 两个平台的app；2.在线升级（差异化升级和整包升级）。到现在公司的两款app也基本做完了，期间还做了很多新需求进去了。总体感觉使用H5做app，做界面比原生简单、快，但是用户体验上没法和原生相比，特别是这种电商类的app，一般项目都比较大、页面跳转复杂、业务逻辑多，使用上和原生相比没有任何优势（忽略上面的两点）；加上五一之后，苹果生审核政策变了，主要是审核加速了，以前需要两周左右的时间现在一周内就可以搞定（一次是4月29号提交的，1天通过；一次是6月15号提交的，一天通过；还有一次是7月5号提交的，花了两三天也通过了）。而且苹果的政策是严禁应用内升级的。以前做了版本号显示的，点击可以跳转到苹果商店升级都被拒绝了，后来干脆把这个功能干掉了，因为苹果现在应用升级它都会推送给用户，不需要我们再在app里面做检查更新操作了，但是对于企业包来说，可以忽略这些。安卓的各大市场上线时间也是很快的，基本可以不考虑。再来看看上面两点：感觉就是第一点有优势，因为可以节约成本，而且我们把app的代码组做些修改就可以是做成微信版本的。个人观点：对于小型app或是app里面的部分模块可以使用H5开发，对于大型的app，不建议使用H5做，因为节约的这点成本，对于产品因为良好的用户体验而获取的用户来说，这个成本不算什么，一般的公司也很难把H5的app的体验做到和原生相差无几。我们使用的是MUI框架，编译器是HBuilder。这篇博客主要介绍的应用差异化升级。 一、整包升级整包升级，先看看官方的文档《整包(apk/ipa)升级》。官方的介绍也是比较详细的，由于本人没有做过整包升级，所以这里不做描述。但是有一点需要注意的： 二、差异化升级先看官方文档《App资源在线升级更新》《App资源在线差量升级更新》这两篇文章里面已经详细的介绍了差异化升级的流程和制作wgt升级包的步骤和注意事项。在官方的代码的基础上我做了一点小的修改。首先新建一个update.js的文件，里面的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var wgtVer=null;function plusReady()&#123; // 获取本地应用资源版本号 plus.runtime.getProperty(plus.runtime.appid,function(inf)&#123; wgtVer=inf.version; console.log("当前应用版本："+wgtVer); &#125;);&#125;if(window.plus)&#123; plusReady();&#125;else&#123; document.addEventListener('plusready',plusReady,false);&#125;// 检测更新// 实际项目中需要更换为自己服务器的地址var checkUrl="http://demo.dcloud.net.cn/test/update/check.php";function checkUpdate()&#123; plus.nativeUI.showWaiting("检测更新..."); var xhr=new XMLHttpRequest(); xhr.onreadystatechange=function()&#123; switch(xhr.readyState)&#123; case 4: plus.nativeUI.closeWaiting(); if(xhr.status==200)&#123; console.log("检测更新成功："+xhr.responseText); var newVer=xhr.responseText; if(wgtVer&amp;&amp;newVer&amp;&amp;(wgtVer!=newVer))&#123; downWgt(); // 下载升级包 &#125;else&#123; plus.nativeUI.alert("无新版本可更新！"); &#125; &#125;else&#123; console.log("检测更新失败！"); plus.nativeUI.alert("检测更新失败！"); &#125; break; default: break; &#125; &#125; xhr.open('GET',checkUrl); xhr.send();&#125;// 下载wgt文件// 实际项目中需要更换为自己服务器的地址var wgtUrl="http://demo.dcloud.net.cn/test/update/H5EF3C469.wgt";function downWgt()&#123; plus.nativeUI.showWaiting("下载wgt文件..."); plus.downloader.createDownload( wgtUrl, &#123;filename:"_doc/update/"&#125;, function(d,status)&#123; if ( status == 200 ) &#123; console.log("下载wgt成功："+d.filename); plus.nativeUI.confirm("升级包下载完成，是否需要升级",function(e)&#123; var sure = (e.index == 0) ? "Yes" : "No"; if (sure == 'Yes') &#123; installWgt(d.filename); // 安装wgt包 &#125; &#125;) &#125; else &#123; console.log("下载wgt失败！"); plus.nativeUI.alert("下载wgt失败！"); &#125; plus.nativeUI.closeWaiting(); &#125;).start();&#125;// 更新应用资源function installWgt(path)&#123; plus.nativeUI.showWaiting("安装wgt文件..."); plus.runtime.install(path,&#123;&#125;,function()&#123; plus.nativeUI.closeWaiting(); console.log("安装wgt文件成功！"); plus.nativeUI.alert("应用资源更新完成!\n点击确定按钮重启完成升级",function()&#123; plus.runtime.restart(); &#125;); &#125;,function(e)&#123; plus.nativeUI.closeWaiting(); console.log("安装wgt文件失败["+e.code+"]："+e.message); plus.nativeUI.alert("安装wgt文件失败["+e.code+"]："+e.message); &#125;);&#125;/* * 差异化升级流程： * 1.启动app后在plusReady里面首先获取app版本 * 2.检查服务器版本 * 3.服务器版本大于本地app版本下载升级包，提示安装和升级 * 4.服务器版本小于等于本地版本时，不做任何操作 * 5.重启即可玩升级 */ 怎么使用呢？我们只需要在一个.html文件里面引用这个js文件： 1&lt;script type="text/javascript" src="../js/update.js" &gt;&lt;/script&gt; 然后在mui.plusReady()方法里面调用checkUpdate()这个方法即可。 三、改进点 升级的js文件里面不要使用Loading框，版本检测或是下载就让它静默操作就可以，值需要在是否安装升级包的时候给一个提示框即可； 根据之前原生app被拒绝的经历来和用户体验的角度来说，我们可以在近app的时候定时一定时间后再调用checkUpdate()这个方法，如果能做一个软开关最好，上架审核期间先关闭这个功能，审核通过以后再打开这个功能。 四、总结H5的app也做了两个，加之之前做原生的经验，总体来说使用H5开发app比原生简单一些、开发速度快，但是用户体验差。公司做产品也是在产品质量、开发周期、成本等因素中选取一个平衡点。代码下载地址：请点击我！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(十)首次启动轮播页的制作]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E5%8D%81)%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%E8%BD%AE%E6%92%AD%E9%A1%B5%E7%9A%84%E5%88%B6%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[现在几乎每个app在启动的时候都会有一个轮播页，要么是广告，要么是app介绍。在《Swift 项目首次启动轮播页的制作》介绍了一种原生应用里面启动页制作的思路：app首先运行的AppDelegate,我们要做的就是在这个里面切换跟控制器。在使用HBuilder开发WebApp制作启动页的时候，制作思路基本是一样的。 一、制作过程页面基本结构就是一个swiper,关于HBuilder里面的swiper和swiper插件的使用，可以查看《HBuilder webApp开发开发(三)轮播图swiper》。这里主要是在最后一页点击“立即体验”时设置一个值，然后在跟页面里面根据这个值，做不同的处理。但是在MUI里面需要设置一下全屏和手动关闭启动界面。 设置全屏 1plus.navigator.setFullscreen(true); 这句代码只对iOS系统的手机适用，在安卓机上面无效。 手动关闭启动界面 我们需要在manifest.json的启动图片splash配置里面这设置： 二、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Hello MUI&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;link rel="stylesheet" href="../css/mui.min.css"&gt; &lt;style&gt; #close &#123; position: absolute; width: 160px; height: 44px; left: 50%; margin-left: -80px; bottom: 15%; padding: 10px; color: #fff; border-color: #fff; &#125; img &#123; width: 100%; height: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="slider" class="mui-slider mui-fullscreen" style="background-color: black;"&gt; &lt;div class="mui-slider-group"&gt; &lt;!-- 第一张 --&gt; &lt;div class="mui-slider-item mui-slider-item-duplicate"&gt; &lt;img src="../images/index.png"&gt; &lt;/div&gt; &lt;!-- 第二张 --&gt; &lt;div class="mui-slider-item"&gt; &lt;img src="../images/index.png"&gt; &lt;/div&gt; &lt;!-- 第三张 --&gt; &lt;div class="mui-slider-item"&gt; &lt;img src="../images/index.png"&gt; &lt;/div&gt; &lt;!-- 第四张 --&gt; &lt;div class="mui-slider-item"&gt; &lt;img src="../images/index.png"&gt; &lt;button id='close' class="mui-btn mui-btn-warning mui-btn-outlined"&gt;立即体验&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="mui-slider-indicator"&gt; &lt;div class="mui-indicator mui-active"&gt;&lt;/div&gt; &lt;div class="mui-indicator"&gt;&lt;/div&gt; &lt;div class="mui-indicator"&gt;&lt;/div&gt; &lt;div class="mui-indicator"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="../js/mui.min.js"&gt;&lt;/script&gt; &lt;script&gt; mui.back = function() &#123;&#125;; mui.plusReady(function() &#123; plus.navigator.setFullscreen(true); plus.navigator.closeSplashscreen(); &#125;); //立即体验按钮点击事件 document.getElementById("close").addEventListener('tap', function(event) &#123; plus.storage.setItem("lauchFlag", "true"); plus.navigator.setFullscreen(false); plus.webview.currentWebview().close(); &#125;, false); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 有了上面的思路和配置后，代码的实现就比较好做了。这段代码是启动页的制作。但是在跟页面里面需要加一段代码： 12345678910111213141516171819202122function launchScreen() &#123; //读取本地存储，检查是否为首次启动 var showGuide = plus.storage.getItem("lauchFlag"); if(showGuide)&#123; //有值，说明已经显示过了，无需显示； //关闭splash页面； plus.navigator.closeSplashscreen(); plus.navigator.setFullscreen(false); &#125;else&#123; //显示启动导航 mui.openWindow(&#123; id:'guide', url:'template/guide.html', show:&#123; aniShow:'none' &#125;, waiting:&#123; autoShow:false &#125; &#125;); &#125;&#125; 然后在mui.plusReady里面，第一行就调用launchScreen()这个方法。 三、最后具体项目的代码：请点击我！写代码前，先理清思路，或是写的时候写好注释，也只自己思路的一种体现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(九)微信-QQ-新浪登录]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E4%B9%9D)%E5%BE%AE%E4%BF%A1-QQ-%E6%96%B0%E6%B5%AA%E7%99%BB%E5%BD%95%2F</url>
      <content type="text"><![CDATA[接着昨天的《HBuilder webApp开发开发(七)微信/QQ/新浪分享》继续写了一下第三方登录。首先是去官方文档和Demo找，发现官方文档基本就是那些配置的说明，但是Demo就需要去github上面查看-传送门还好官方有Demo,不然真的不知道怎么下手。在写代码之前，首先是查看文档和Demo，相关的appkey，还是可以从ShareSDK上面获取。看官方Demo,主要是看明白流程和关键代码怎么写。 一、项目配置项目配置，可以参考《HBuilder webApp开发开发(七)微信/QQ/新浪分享》介绍的做就可以了。 二、登录流程 获取登录服务 （类似原生的注册）； 登录认证； 获取登录信息； 解析登录信息 登录成功胡注销登录。 简单说说为什么要注销：例如微信登录，第一次登录之后，下次再点击登录，不会再次调起微信，因为登录具有时效性和缓存，所以我们需要在下次登录之前先注销或是在我们每次登录成功之后就注销。因为我们每次登录主要说获取对用平台的信息，获取之后就可以及时注销了。实际在做原生的时候也是这么处理的。 三、效果图 四、代码关于代码其实没什么好说的，看明白了官方的Demo,知道了流程就好处理的，可能就是有时或忘记了注销。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Hello MUI&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;!--标准mui.css--&gt; &lt;link rel="stylesheet" href="../css/mui.min.css"&gt; &lt;link rel="stylesheet" href="../css/mui.css" /&gt; &lt;!--App自定义的css--&gt; &lt;style type="text/css"&gt; .head &#123; margin-top: 10px; &#125; .head img&#123; width: 120px; height: 120px; margin-left: calc(50% - 60px); &#125; .top &#123; margin-top: 40px; &#125; .sinaweibo &#123; position: relative; width: 60px; height: 60px; margin-left: calc(50% - 30px); background: url(../images/icon-sina.png); &#125; .weixin &#123; width: 60px; height: 60px; margin-left: calc(50% - 30px); background: url(../images/icon-weixin.png); &#125; .qq &#123; width: 60px; height: 60px; margin-left: calc(50% - 30px); background: url(../images/icon-qq.png); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header class="mui-bar mui-bar-nav"&gt; &lt;a class="mui-action-back mui-icon mui-icon-left-nav mui-pull-left"&gt;&lt;/a&gt; &lt;h1 class="mui-title"&gt;第三方登录&lt;/h1&gt; &lt;/header&gt; &lt;div class="mui-content"&gt; &lt;div class="head"&gt; &lt;img src="../images/Icon@2x.png" id="headImage"/&gt; &lt;/div&gt; &lt;div class="top" id="testLogin"&gt; &lt;span class="mui-icon weixin" id="weixin"&gt;&lt;/span&gt; &lt;a&gt;&lt;span class="mui-icon qq" id="qq"&gt;&lt;/span&gt; &lt;span class="mui-icon sinaweibo" id="sinaweibo"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="../js/mui.min.js"&gt;&lt;/script&gt; &lt;script src="../js/mui.zoom.js"&gt; &lt;/script&gt; &lt;script src="../js/mui.previewimage.js"&gt;&lt;/script&gt; &lt;script src="../js/tools.js" &gt;&lt;/script&gt; &lt;script&gt; // 获取用户头像标签 var headImage = document.getElementById('headImage'); mui.init(&#123; swipeBack:true //启用右滑关闭功能 &#125;); mui.plusReady(function() &#123; plus.oauth.getServices(function(services) &#123; auths = services; &#125;, function(e) &#123; alert("获取登录服务列表失败：" + e.message + " - " + e.code); &#125;); &#125;) document.getElementById('weixin').addEventListener('tap',function() &#123; console.log("微信"); authLogin('weixin'); &#125;) document.getElementById('qq').addEventListener('tap',function() &#123; console.log("QQ"); authLogin('qq'); &#125;) document.getElementById('sinaweibo').addEventListener('tap',function() &#123; console.log("微博"); authLogin('sinaweibo'); &#125;) // 登录操作 function authLogin(type) &#123; var s; for (var i = 0; i &lt; auths.length; i++) &#123; if (auths[i].id == type) &#123; s = auths[i]; break; &#125; &#125; if (!s.authResult) &#123; s.login(function(e) &#123; mui.toast("登录认证成功！"); authUserInfo(type); &#125;, function(e) &#123; mui.toast("登录认证失败！"); &#125;); &#125; else &#123; mui.toast("已经登录认证！"); &#125; &#125; //注销 function authLogout() &#123; for (var i in auths) &#123; var s = auths[i]; if (s.authResult) &#123; s.logout(function(e) &#123; console.log("注销登录认证成功！"); &#125;, function(e) &#123; console.log("注销登录认证失败！"); &#125;); &#125; &#125; &#125; // 微信登录认证信息 function authUserInfo(type) &#123; var s; for (var i = 0; i &lt; auths.length; i++) &#123; if (auths[i].id == type) &#123; s = auths[i]; break; &#125; &#125; if (!s.authResult) &#123; mui.toast("未授权登录！"); &#125; else &#123; s.getUserInfo(function(e) &#123; var josnStr = JSON.stringify(s.userInfo); var jsonObj = s.userInfo; console.log("获取用户信息成功：" + josnStr); showData(type,jsonObj); authLogout(); &#125;, function(e) &#123; alert("获取用户信息失败：" + e.message + " - " + e.code); &#125;); &#125; &#125; // 显示用户头像信息 function showData(type,data) &#123; switch (type)&#123; case 'weixin': headImage.src = data.headimgurl; break; case 'qq': headImage.src = data.figureurl_qq_2; break; case 'sinaweibo': headImage.src = data.avatar_large; break; default: break; &#125; &#125; &lt;/script&gt;&lt;/html&gt; 五、总结在这篇博客里面准备使用js的委托代理的，因为每个对应平台的图标的点击事件基本是一样的，但是还是不会使用，所以还是使用的事件绑定的方式。代码下载地址：请点击我！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(八)微信-QQ-新浪-腾讯微博分享]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E5%85%AB)%E5%BE%AE%E4%BF%A1-QQ-%E6%96%B0%E6%B5%AA-%E8%85%BE%E8%AE%AF%E5%BE%AE%E5%8D%9A%E5%88%86%E4%BA%AB%2F</url>
      <content type="text"><![CDATA[HBuilder是支持微信分享（好友和朋友圈），QQ分享，新浪微博和腾讯微博分享。但是在使用的过程中，官方给的文档似乎很坑爹。《分享插件配置》《分享插件开发指南》都是2014年7月发表的文档，后期也没看见更新说明；有用户过来提问，就都给引导去看这两篇文档，真不知道有什么好看的。在公司的项目中，实际也使用了分享。昨天下班回去就重新写了一下代码，弄到半夜12点多。 一、HBuilder的配置 配置权限双加manifest.json文件，我们需要先配置权限（默认是有分享权限的）所以我们只需要再看看核实一下。 配置相关的appkey打开manifest.json的SDK配置视图。这些appkey我们可以在其他第三方平台上面获取做测试。例如ShareSDK。实际项目中需要实际自己公司的。再勾选对应的平台。 查看代码视图代码视图里面我们只需要看看有这些东西就可以了。不需要修改。 二、基本界面和工作流程 界面界面里面我已经把存在的问题和解决方案都列出来了。 工作流程点击右上角的分享按钮，弹出分享视图，选择相应的平台，然后就会跳转到对应的平台，分享成功之后就会返回我们的应用，原生应用也是这样的流程。但是在HBuilder里面多了一个更新分享服务，也许就相当无原生里面的注册吧。详细可以看看下面的代码。 三、代码代码部分注释都有了，使用流程也会更加清晰。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Hello MUI&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;!--标准mui.css--&gt; &lt;link rel="stylesheet" href="../css/mui.min.css"&gt; &lt;link rel="stylesheet" href="../css/mui.css" /&gt; &lt;!--App自定义的css--&gt; &lt;style type="text/css"&gt; .share &#123; float: right; &#125; .tip-title &#123; font-size: 20px; color: blue; padding-left: 10px; &#125; .content &#123; padding-top: 5px; padding-bottom: 10px; padding-left: 10px; &#125; .content span &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header class="mui-bar mui-bar-nav"&gt; &lt;a class="mui-action-back mui-icon mui-icon-left-nav mui-pull-left"&gt;&lt;/a&gt; &lt;a class="share mui-icon mui-icon-redo" onclick="shareHref()"&gt;&lt;/a&gt; &lt;h1 class="mui-title"&gt;第三方分享&lt;/h1&gt; &lt;/header&gt; &lt;div class="mui-content"&gt; &lt;span class="tip-title"&gt;分享平台:&lt;/span&gt;&lt;br&gt; &lt;div class="content"&gt; 1.微信分享:微信好友/微信朋友圈 &lt;br&gt; 2.QQ分享 &lt;br&gt; 3.新浪微博分享 &lt;br&gt; &lt;/div&gt; &lt;span class="tip-title"&gt;注意事项:&lt;/span&gt;&lt;br&gt; &lt;div class="content"&gt; &lt;span&gt; 微信分享图片大小不能超过32kb限制 &lt;br&gt; &lt;/span&gt; &lt;/div&gt; &lt;span class="tip-title"&gt;解决办法:&lt;/span&gt;&lt;br&gt; &lt;div class="content"&gt; 1.把分享的图片的url转换成图片对象image; &lt;br&gt; 2.把生成的图片对象image压缩后上传服务器返回新的图片的url; &lt;br&gt; 3.分享图片地址使用压缩上传后从服务器获取的url; &lt;br&gt; 或者：&lt;br&gt; 第一次服务器返回的图片的体积就是32kb以下的. &lt;br&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="../js/mui.min.js"&gt;&lt;/script&gt; &lt;script src="../js/mui.zoom.js"&gt; &lt;/script&gt; &lt;script src="../js/mui.previewimage.js"&gt;&lt;/script&gt; &lt;script src="../js/tools.js" &gt;&lt;/script&gt; &lt;script&gt; mui.init(&#123; swipeBack:true //启用右滑关闭功能 &#125;); var Intent = null, File = null, Uri = null, main = null; var shares = null; var shareImageUrl = ''; mui.plusReady(function() &#123; updateSerivces(); if (plus.os.name == "Android") &#123; Intent = plus.android.importClass("android.content.Intent"); File = plus.android.importClass("java.io.File"); Uri = plus.android.importClass("android.net.Uri"); main = plus.android.runtimeMainActivity(); &#125; &#125;) /** * 更新分享服务 */ function updateSerivces() &#123; plus.share.getServices(function(s) &#123; shares = &#123;&#125;; for (var i in s) &#123; var t = s[i]; shares[t.id] = t; &#125; outSet("获取分享服务列表成功"); &#125;, function(e) &#123; outSet("获取分享服务列表失败：" + e.message); &#125;); &#125; /** * 分享操作 */ function shareAction(id, ex) &#123; var s = null; if (!id || !(s = shares[id])) &#123; outLine("无效的分享服务！"); return; &#125; if (s.authenticated) &#123; outSet("---已授权---"); shareMessage(s, ex); &#125; else &#123; outSet("---未授权---"); s.authorize(function() &#123; shareMessage(s, ex); &#125;, function(e) &#123; outLine("认证授权失败"); &#125;); &#125; &#125; /** * 发送分享消息 */ function shareMessage(s, ex) &#123; var msg = &#123; content: '分享-详情', href: 'http://blog.csdn.net/zhuming3834', title: 'HGDQ-分享测试-title', content: 'HGDQ-分享测试-content', thumbs: ['http://img3.3lian.com/2013/v10/4/87.jpg'], pictures: ['http://img3.3lian.com/2013/v10/4/87.jpg'], extra: &#123; scene: ex &#125; &#125;; s.send(msg, function() &#123; outLine("分享成功!"); &#125;, function(e) &#123; outLine("分享失败!"); &#125;); &#125; /** * 分享按钮点击事件 */ function shareHref() &#123; var ids = [&#123; id: "weixin", ex: "WXSceneSession" /*微信好友*/ &#125;, &#123; id: "weixin", ex: "WXSceneTimeline" /*微信朋友圈*/ &#125;, &#123; id: "qq" /*QQ好友*/ &#125;, &#123; id: "tencentweibo" /*腾讯微博*/ &#125;,&#123; id: "sinaweibo" /*新浪微博*/ &#125;], bts = [&#123; title: "发送给微信好友" &#125;, &#123; title: "分享到微信朋友圈" &#125;, &#123; title: "分享到QQ" &#125;, &#123; title: "分享到腾讯微博" &#125;, &#123; title: "分享到新浪微博" &#125;]; plus.nativeUI.actionSheet(&#123; cancel: "取消", buttons: bts &#125;, function(e) &#123; var i = e.index; if (i &gt; 0) &#123; shareAction(ids[i - 1].id, ids[i - 1].ex); &#125; &#125; ); &#125; // 控制台输出日志 function outSet(msg) &#123; console.log(msg); &#125; // 界面弹出吐司提示 function outLine(msg) &#123; mui.toast(msg); &#125; &lt;/script&gt;&lt;/html&gt; 实际使用过程中只需要这么操作就可以了。 四、遇见的坑前天晚上在做原生的iOS时，测试给提了一个bug,有的地方可以调起微信分享，有的不行。以前是出现过这关问题，后来其他同事解决了。前天我就有看了一下之前同事的代码，发现了里面的坑。之前他们的图片压缩是使用的： 12UIImageJPEGRepresentation(图片对象，压缩系数) // 项目里面压缩系数固定是0.01 使用这个方法做的，之前解决了问题。然后前天在分析中发现这个方法有时会把图片越压缩体积越大。比如图片体积只有37kb,压缩之后可能会有58kb左右，但是对于500+kb的图片，压缩之后的图片体积可以达到32kb以下。（万恶的微信，万恶的32kb限制）。最后分析了一下分享的图片是在那里使用的左边的小图，才是分享出去的。想想之前自己做二维码（《CoreImage原生二维码生成（一）》）的时候，使用过的方法。我的解决办法是，直接把调用上面UIImageJPEGRepresentation压缩之后的图片再压缩成制定尺寸的图片，然后分享。 12345678910111213141516/** * 大图片压缩成制定尺寸的图片 * * @param img 需要压缩的图片 * @param size 目标尺寸 * * @return 压缩后的图片 */+ (UIImage *)scaleTosize:(UIImage *)img size:(CGSize)size&#123; // 创建一个bitmap的context // 并把它设置成为当前正在使用的context UIGraphicsBeginImageContext(size); [img drawInRect:CGRectMake(0, 0, size.width, size.height)]; UIImage *scaledImage = UIGraphicsGetImageFromCurrentImageContext(); return scaledImage;&#125; 在上面的二维码生成中我使用的方法大家可以查看之前的博客。 然而在HBuilder里面分享的图片的url,即使通过url获取的图片最终超过32kb也不能使用微信分享。解决办法就是：1.把分享的图片的url转换成图片对象image;2.把生成的图片对象image压缩后上传服务器返回新的图片的url;3.分享图片地址使用压缩上传后从服务器获取的url;或者：第一次服务器返回的图片的体积就是32kb以下的。这个微信分享图片32kb的限制，昨晚坑了我一下，最后在HBuilder官网去找答案，最后无果。后来想想，前天刚刚解决了这个问题，问题，问题是微信对从苹果手机端分享出去图片大小的限制，实际在安卓机器上面是没限制的。 五、最后关于效果图，大家可以去我的github下载查看，CSDN上传图片不能超过2M.代码下载地址：请点击我！ 更新日志： 2016.07.12应CSDN网友u012155655 要求，增加腾讯微博分享，github代码已更新。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(七)事件绑定]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E4%B8%83)%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
      <content type="text"><![CDATA[在做公司项目的时候，有一个页面有个个数不定的勾选框checkbox视图区，每个勾选框对应一个ID和NAME的值，我们需要把选中的chexkbox的ID获取到，然后以拼接成字符串，字符中间用“,”分割。在这个需求里面有三个点，1：不定选项的checkbox; 2:获取选中的checkbox的ID; 3:字符串中间使用“,”拼接。关于上面的三个知识点来说,个人任我最难的是第2个，难点在在使用H5做的时候我还不知道js的时间绑定中的这种方法，我们虽说是要获取选中的checkbox的ID,实际这些需要在checkbox的点击时间里面去处理。以前做原生的时候是在button的点击事件里面处理的，每个button的tag值我们可以设置为0~n,然后根据tag值从数据源数组里面去取数据。但是在H5里面去不能这样处理，使用下面的事件绑定方法： 1document.getElementById('imageView').addEventListener('tap',function()&#123;&#125;) 这个事件绑定的方式有个特点就是需要知道每个checkbox的id,然后一个id有一个事件绑定方法。显然这么做是难以接受的，因为checkbox的个数不定。还有一点就是,保存选中checkbox的ID,再加上每个checkbox都存在多次点击的时候,这个时候就需要在存储ID的容器里面处理选中的时候存储的是ID,非选中的时候存储的不是ID。想到每个ID的唯一性和字典里面key的唯一性,下面的就好做了。每一个checkbox对应字典里面的一个键值对,key是ID,选中时的value是ID，非选中的时候value不是ID(这里我们假定为是“X”);然后在checkbox点击事件里面，当checkbox被选中时，设置其对应的键值对的value为对应的ID，否则设置为“X”。这里还是没有说到这篇博客的重点，事件绑定。其实这也是这么一个功能点,我认为对我来说我需要学习的一个知识点,所以我叫他事件绑定。 一、效果图这里初始设置的每个按钮是未选中状态。 二、js事件绑定《JavaScript事件绑定》《Javascript事件绑定的几种方式》关于Javascript的事件绑定，可以看看上面两篇文章。但在实际使用中我们需要多看看mui提供的方式，因为平台和环境不一样。 三、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Hello MUI&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;!--标准mui.css--&gt; &lt;link rel="stylesheet" href="../css/mui.min.css"&gt; &lt;link rel="stylesheet" href="../css/mui.css" /&gt; &lt;!--App自定义的css--&gt; &lt;style type="text/css"&gt; .mui-checkbox&#123; height: 44px; background: white; border-bottom-style: solid; border-bottom-color: #F3F3F3; border-bottom-width: 1px; &#125; .span &#123; float: right; margin-right: 150px; height: 44px; line-height: 44px; &#125; .checkbox &#123; margin-top: 5px; margin-right: 200px; height: 44px; line-height: 44px; &#125; .checkbox :before &#123; 0px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header class="mui-bar mui-bar-nav"&gt; &lt;a class="mui-action-back mui-icon mui-icon-left-nav mui-pull-left"&gt;&lt;/a&gt; &lt;h1 class="mui-title"&gt;事件绑定&lt;/h1&gt; &lt;/header&gt; &lt;div class="mui-content"&gt; &lt;div class="mui-checkbox"&gt; &lt;span class="span"&gt;我的id:1&lt;/span&gt; &lt;input type="checkbox" class="checkbox" id="" value="" /&gt; &lt;/div&gt; &lt;div class="mui-checkbox"&gt; &lt;span class="span"&gt;我的id:2&lt;/span&gt; &lt;input type="checkbox" class="checkbox" id="" value="" /&gt; &lt;/div&gt; &lt;div class="mui-checkbox"&gt; &lt;span class="span"&gt;我的id:3&lt;/span&gt; &lt;input type="checkbox" class="checkbox" id="" value="" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="../js/mui.min.js"&gt;&lt;/script&gt; &lt;script src="../js/mui.zoom.js"&gt; &lt;/script&gt; &lt;script src="../js/mui.previewimage.js"&gt;&lt;/script&gt; &lt;script src="../js/tools.js" &gt;&lt;/script&gt; &lt;script&gt; var checkDice = new Array(); mui.init(&#123; swipeBack:true //启用右滑关闭功能 &#125;); mui.plusReady(function() &#123; getData(); &#125;) // 数据处理 function getData() &#123; var content = document.body.querySelector('.mui-content'); content.innerHTML = ''; var count = Math.random()*10 | 0; // 获取0~10之间的整数 count = count + 5; // 6~16之间 console.log(count); for (var index = 0; index &lt; count; index ++ ) &#123; var div = document.createElement('mui-checkbox'); div.innerHTML = '&lt;div class="mui-checkbox"&gt;' + '&lt;span class="span"&gt;我的ID:' + index + '&lt;/span&gt;' + '&lt;input type="checkbox" class="checkbox" id="' + index +'" value="" /&gt;&lt;/div&gt;'; content.appendChild(div,content.firstChild); checkDice[String(index)] = 'X'; &#125; &#125; // 事件绑定 mui('.mui-content').on('change','input',function()&#123; console.log("id = " + this.id + " status = " + this.checked); if (this.checked) &#123; checkDice[this.id] = this.id; &#125; else&#123; checkDice[this.id] = 'X'; &#125; console.log("checkDice = " + checkDice); console.log('被选中的checkbox的ID是：',makeData(checkDice)); &#125;) // 数据处理 function makeData(dice)&#123; var result = ''; for (var key in dice) &#123; if (dice[key] != 'X') &#123; result = result + dice[key] + ','; &#125; &#125; // 去除字符串最后的','后返回 return result.substring(0,result.length - 1); &#125; &lt;/script&gt;&lt;/html&gt; 四、总结写代码前，理清思路，学会多看文档，多思考。代码下载地址：请点击我！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(六)图片墙-图片预览]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E5%85%AD)%E5%9B%BE%E7%89%87%E5%A2%99-%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88%2F</url>
      <content type="text"><![CDATA[在公司的项目中，有个图片墙（有人叫瀑布流）的页面，可以查看图片列表，点击可以预览图片。以前使用OC和Swift都写过瀑布流：OC版本-【iOS】UITableView实现的瀑布流效果Swift版本- Swift UITableView瀑布流/NSURLConnection异步网络请求在公司的项目里面虽说不是我做的这一块，但是不做就不代表不去学习。看了公司的项目里面的做法，也看了HBuilder的mui提供的样式，自己总结了一下就写出来了，效果是一样的。 一、效果图 放大后的图片是支持缩放的。 二、代码部分 找到mui的例子在mui的事例项目的examples目录下面有imageviewer.html这个文件，找到它，先运行看看效果。会发现连有我们需要的-点击图片可以方法查看，还可以左右滑动。然后就是读懂例子，找到我们需要的css样式部分。 新建imageview.css样式文件然后把mui里imageviewer.html的样式部分copy进我们的css文件。css样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147.mui-preview-image.mui-fullscreen &#123; position: fixed; z-index: 20; background-color: #000;&#125;.mui-preview-header,.mui-preview-footer &#123; position: absolute; width: 100%; left: 0; z-index: 10;&#125;.mui-preview-header &#123; height: 44px; top: 0;&#125;.mui-preview-footer &#123; height: 50px; bottom: 0px;&#125;.mui-preview-header .mui-preview-indicator &#123; display: block; line-height: 25px; color: #fff; text-align: center; margin: 15px auto 4; width: 70px; background-color: rgba(0, 0, 0, 0.4); border-radius: 12px; font-size: 16px;&#125;.mui-preview-image &#123; display: none; -webkit-animation-duration: 0.5s; animation-duration: 0.5s; -webkit-animation-fill-mode: both; animation-fill-mode: both;&#125;.mui-preview-image.mui-preview-in &#123; -webkit-animation-name: fadeIn; animation-name: fadeIn;&#125;.mui-preview-image.mui-preview-out &#123; background: none; -webkit-animation-name: fadeOut; animation-name: fadeOut;&#125;.mui-preview-image.mui-preview-out .mui-preview-header,.mui-preview-image.mui-preview-out .mui-preview-footer &#123; display: none;&#125;.mui-zoom-scroller &#123; position: absolute; display: -webkit-box; display: -webkit-flex; display: flex; -webkit-box-align: center; -webkit-align-items: center; align-items: center; -webkit-box-pack: center; -webkit-justify-content: center; justify-content: center; left: 0; right: 0; bottom: 0; top: 0; width: 100%; height: 100%; margin: 0; -webkit-backface-visibility: hidden;&#125;.mui-zoom &#123; -webkit-transform-style: preserve-3d; transform-style: preserve-3d;&#125;.mui-slider .mui-slider-group .mui-slider-item img &#123; width: auto; height: auto; max-width: 100%; max-height: 100%;&#125;.mui-android-4-1 .mui-slider .mui-slider-group .mui-slider-item img &#123; width: 100%;&#125;.mui-android-4-1 .mui-slider.mui-preview-image .mui-slider-group .mui-slider-item &#123; display: inline-table;&#125;.mui-android-4-1 .mui-slider.mui-preview-image .mui-zoom-scroller img &#123; display: table-cell; vertical-align: middle;&#125;.mui-preview-loading &#123; position: absolute; width: 100%; height: 100%; top: 0; left: 0; display: none;&#125;.mui-preview-loading.mui-active &#123; display: block;&#125;.mui-preview-loading .mui-spinner-white &#123; position: absolute; top: 50%; left: 50%; margin-left: -25px; margin-top: -25px; height: 50px; width: 50px;&#125;.mui-preview-image img.mui-transitioning &#123; -webkit-transition: -webkit-transform 0.5s ease, opacity 0.5s ease; transition: transform 0.5s ease, opacity 0.5s ease;&#125;@-webkit-keyframes fadeIn &#123; 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;&#125;@keyframes fadeIn &#123; 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;&#125;@-webkit-keyframes fadeOut &#123; 0% &#123; opacity: 1; &#125; 100% &#123; opacity: 0; &#125;&#125;@keyframes fadeOut &#123; 0% &#123; opacity: 1; &#125; 100% &#123; opacity: 0; &#125;&#125; .html文件在.html文件里面就比较好弄了。首先link这个css文件（其他部分和以前一样）。然后就是写我们的界面了网络请求了，接口还是一样的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Hello MUI&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;!--标准mui.css--&gt; &lt;link rel="stylesheet" href="../css/mui.min.css"&gt; &lt;link rel="stylesheet" href="../css/mui.css" /&gt; &lt;link rel="stylesheet" href="../css/imageview.css" /&gt; &lt;!--App自定义的css--&gt; &lt;style type="text/css"&gt; .leftImage &#123; margin-top: 10px; width: 45%; height: 200px; margin-left: 10px; float: left; &#125; .rightImage &#123; margin-top: 10px; width: 45%; height: 200px; margin-right: 10px; float: right; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header class="mui-bar mui-bar-nav"&gt; &lt;a class="mui-action-back mui-icon mui-icon-left-nav mui-pull-left"&gt;&lt;/a&gt; &lt;h1 class="mui-title"&gt;图片预览&lt;/h1&gt; &lt;/header&gt; &lt;div class="mui-content"&gt; &lt;ul class="mui-table-view"&gt; &lt;li class="image-li"&gt; &lt;img class="leftImage" src="../images/yuantiao.jpg" data-preview-src="" data-preview-group="1" /&gt; &lt;img class="rightImage" src="../images/yuantiao.jpg" data-preview-src="" data-preview-group="1" /&gt; &lt;/li&gt; &lt;li class="image-li"&gt; &lt;img class="leftImage" src="../images/yuantiao.jpg" data-preview-src="" data-preview-group="1" /&gt; &lt;img class="rightImage" src="../images/yuantiao.jpg" data-preview-src="" data-preview-group="1" /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="../js/mui.min.js"&gt;&lt;/script&gt; &lt;script src="../js/mui.zoom.js"&gt; &lt;/script&gt; &lt;script src="../js/mui.previewimage.js"&gt;&lt;/script&gt; &lt;script src="../js/tools.js" &gt;&lt;/script&gt; &lt;script&gt; mui.previewImage(); mui.plusReady(function() &#123; getaData(); &#125;) // 获取数据 function getaData() &#123; var table = document.body.querySelector('.mui-table-view'); var timestamp = getDataStr(); mui.ajax(baseUrl, &#123; data: &#123; key: '', typeId: '', showapi_appid: appid, showapi_sign: sign, showapi_timestamp: timestamp, page:1 &#125;, dataType: 'json', type: 'post', timeout: 10000, beforeSend: function(data) &#123; plus.nativeUI.showWaiting(); &#125;, success: function(data) &#123; plus.nativeUI.closeWaiting(); if (data.showapi_res_code == 0) &#123; console.log("imageView成功"); var dice1 = data.showapi_res_body; var dice2 = dice1.pagebean; table.innerHTML = ''; for (var i = 0; i &lt; dice2.contentlist.length - 1; i = i + 2) &#123; var item1 = dice2.contentlist[i]; var item2 = dice2.contentlist[i + 1];// console.log(item1.contentImg); var li = document.createElement('li'); li.className = 'image-li'; li.innerHTML = '&lt;img class="leftImage" src="'+ item1.contentImg + '" data-preview-src="" data-preview-group="1" /&gt;' + '&lt;img class="rightImage" src="'+ item2.contentImg + '" data-preview-src="" data-preview-group="1" /&gt;'; table.appendChild(li, table.firstChild); &#125; &#125; &#125;, error: function(xhr, type, errerThrown) &#123; mui.toast('网络异常,请稍候再试'); plus.nativeUI.closeWaiting(); &#125; &#125;); &#125; &lt;/script&gt;&lt;/html&gt; 代码部分难点就在css文件部分，但是这一部分mui都帮我们做了。我么要做的就是做我们的界面和请求数据。 三、总结写代码一定要思路清晰，然后仔细的一点一点的写，有Bug就耐心的调，等把效果做出来后，发现很多东西也没有那么难。代码下载地址：请点击我！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(五)相册-拍照-图片上传]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E4%BA%94)%E7%9B%B8%E5%86%8C-%E6%8B%8D%E7%85%A7-%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[在做项目的过程中，需要从相册或是拍照，然后上传，比如修改用户头像或是上传项目图片。 一、效果图点击用户头像后，弹出actionSheet，选着从相册或是拍照；选着图片后就调用上传方法，上传图片；在上传之前先压缩了一下图片。 二、使用流程 弹出actionSheet 12345678910111213141516171819202122232425262728/*点击头像触发*/document.getElementById('headImage').addEventListener('tap', function() &#123; if (mui.os.plus) &#123; var a = [&#123; title: "拍照" &#125;, &#123; title: "从手机相册选择" &#125;]; plus.nativeUI.actionSheet(&#123; title: "修改用户头像", cancel: "取消", buttons: a &#125;, function(b) &#123; /*actionSheet 按钮点击事件*/ switch (b.index) &#123; case 0: break; case 1: getImage(); /*拍照*/ break; case 2: galleryImg();/*打开相册*/ break; default: break; &#125; &#125;) &#125;&#125;, false); 拍照上传 12345678910111213141516//拍照function getImage() &#123; var c = plus.camera.getCamera(); c.captureImage(function(e) &#123; plus.io.resolveLocalFileSystemURL(e, function(entry) &#123; var s = entry.toLocalURL() + "?version=" + new Date().getTime(); uploadHead(s); /*上传图片*/ &#125;, function(e) &#123; console.log("读取拍照文件错误：" + e.message); &#125;); &#125;, function(s) &#123; console.log("error" + s); &#125;, &#123; filename: "_doc/head.png" &#125;)&#125; 从相册选图上传 1234567891011121314151617181920212223242526272829303132333435363738394041//本地相册选择function galleryImg() &#123; plus.gallery.pick(function(a) &#123; plus.io.resolveLocalFileSystemURL(a, function(entry) &#123; plus.io.resolveLocalFileSystemURL("_doc/", function(root) &#123; root.getFile("head.png", &#123;&#125;, function(file) &#123; //文件已存在 file.remove(function() &#123; console.log("file remove success"); entry.copyTo(root, 'head.png', function(e) &#123; var e = e.fullPath + "?version=" + new Date().getTime(); uploadHead(e); /*上传图片*/ //变更大图预览的src //目前仅有一张图片，暂时如此处理，后续需要通过标准组件实现 &#125;, function(e) &#123; console.log('copy image fail:' + e.message); &#125;); &#125;, function() &#123; console.log("delete image fail:" + e.message); &#125;); &#125;, function() &#123; //文件不存在 entry.copyTo(root, 'head.png', function(e) &#123; var path = e.fullPath + "?version=" + new Date().getTime(); uploadHead(path); /*上传图片*/ &#125;, function(e) &#123; console.log('copy image fail:' + e.message); &#125;); &#125;); &#125;, function(e) &#123; console.log("get _www folder fail"); &#125;) &#125;, function(e) &#123; console.log("读取拍照文件错误：" + e.message); &#125;); &#125;, function(a) &#123;&#125;, &#123; filter: "image" &#125;)&#125;; 图片上传和压缩 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//上传头像图片function uploadHead(imgPath) &#123; console.log("imgPath = " + imgPath); mainImage.src = imgPath; mainImage.style.width = "60px"; mainImage.style.height = "60px"; var image = new Image(); image.src = imgPath; image.onload = function() &#123; var imgData = getBase64Image(image); /*在这里调用上传接口*/// mui.ajax("图片上传接口", &#123;// data: &#123;// // &#125;,// dataType: 'json',// type: 'post',// timeout: 10000,// success: function(data) &#123;// console.log('上传成功');// &#125;,// error: function(xhr, type, errorThrown) &#123;// mui.toast('网络异常，请稍后再试！');// &#125;// &#125;); &#125;&#125;//将图片压缩转成base64function getBase64Image(img) &#123; var canvas = document.createElement("canvas"); var width = img.width; var height = img.height; // calculate the width and height, constraining the proportions if (width &gt; height) &#123; if (width &gt; 100) &#123; height = Math.round(height *= 100 / width); width = 100; &#125; &#125; else &#123; if (height &gt; 100) &#123; width = Math.round(width *= 100 / height); height = 100; &#125; &#125; canvas.width = width; /*设置新的图片的宽度*/ canvas.height = height; /*设置新的图片的长度*/ var ctx = canvas.getContext("2d"); ctx.drawImage(img, 0, 0, width, height); /*绘图*/ var dataURL = canvas.toDataURL("image/png", 0.8); return dataURL.replace("data:image/png;base64,", "");&#125; 三、总结在使用中，我们可以发现，使用流程是非常清晰的；某种程度来说比原生iOS的使用还要简单一些。代码下载地址：请点击我！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(四)轮播图swiper]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E5%9B%9B)%E8%BD%AE%E6%92%AD%E5%9B%BEswiper%2F</url>
      <content type="text"><![CDATA[在新闻类的App中，首页的轮播图是使用最多的。现在公司的项目中也使用了轮播图。在我的Demo中，昨天也在首页增加了轮播图。代码下载地址：请点击我！分别使用的是mui的样式和Swiper提供的方法各做了一套。 一、效果图上面的轮播图使用的HBuilder自带的mui样式，下面使用的是Swiper的样式。使用后感觉Swiper的在使用上比mui的简单。主要体现就在设置线面的几个小点和循环播放方便。 二、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;link rel="stylesheet" href="../css/mui.min.css"&gt; &lt;link rel="stylesheet" href="../css/app.css" /&gt; &lt;link rel="stylesheet" href="../css/swiper-3.3.1.min.css" /&gt; &lt;style&gt; html,body &#123; background-color: #efeff4; &#125; .title a&#123; font-size: 14px; color: black; &#125; .swiper-container &#123; height: 180px; &#125; .swiper-container img &#123; height: 180px; width: 100%; &#125; .swiper-pagination &#123; margin-bottom: 5px; &#125;; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header class="mui-bar mui-bar-nav black"&gt; &lt;h1 class="mui-title"&gt;首页&lt;/h1&gt; &lt;/header&gt; &lt;div class="mui-content"&gt; &lt;div class="title"&gt; &lt;a&gt;HBuilder自带轮播图样式&lt;/a&gt; &lt;/div&gt; &lt;div id="slider" class="mui-slider" &gt; &lt;div class="mui-slider-group mui-slider-loop"&gt; &lt;!-- 额外增加的一个节点(循环轮播：第一个节点是最后一张轮播) --&gt; &lt;div class="mui-slider-item mui-slider-item-duplicate"&gt; &lt;a href="#"&gt; &lt;img src="../images/yuantiao.jpg"&gt; &lt;/a&gt; &lt;/div&gt; &lt;!-- 第一张 --&gt; &lt;div class="mui-slider-item"&gt; &lt;a href="#"&gt; &lt;img src="../images/shuijiao.jpg"&gt; &lt;/a&gt; &lt;/div&gt; &lt;!-- 第二张 --&gt; &lt;div class="mui-slider-item"&gt; &lt;a href="#"&gt; &lt;img src="../images/muwu.jpg"&gt; &lt;/a&gt; &lt;/div&gt; &lt;!-- 第三张 --&gt; &lt;div class="mui-slider-item"&gt; &lt;a href="#"&gt; &lt;img src="../images/cbd.jpg"&gt; &lt;/a&gt; &lt;/div&gt; &lt;!-- 第四张 --&gt; &lt;div class="mui-slider-item"&gt; &lt;a href="#"&gt; &lt;img src="../images/yuantiao.jpg"&gt; &lt;/a&gt; &lt;/div&gt; &lt;!-- 额外增加的一个节点(循环轮播：最后一个节点是第一张轮播) --&gt; &lt;div class="mui-slider-item mui-slider-item-duplicate"&gt; &lt;a href="#"&gt; &lt;img src="../images/shuijiao.jpg"&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="mui-slider-indicator"&gt; &lt;div class="mui-indicator mui-active"&gt;&lt;/div&gt; &lt;div class="mui-indicator"&gt;&lt;/div&gt; &lt;div class="mui-indicator"&gt;&lt;/div&gt; &lt;div class="mui-indicator"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="title"&gt; &lt;a&gt;http://www.swiper.com.cn/&lt;/a&gt; &lt;/div&gt; &lt;div class="swiper-container"&gt; &lt;div class="swiper-wrapper" id="swiperTest"&gt; &lt;!--&lt;div class="swiper-slide"&gt; &lt;img src="../images/login-1.png" id="test"/&gt; &lt;/div&gt; &lt;div class="swiper-slide"&gt; &lt;img src="../images/login-1.png"/&gt; &lt;/div&gt; &lt;div class="swiper-slide"&gt; &lt;img src="../images/login-1.png"/&gt; &lt;/div&gt;--&gt; &lt;/div&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="../js/mui.min.js"&gt;&lt;/script&gt; &lt;script src="../js/swiper-3.3.1.min.js" &gt;&lt;/script&gt; &lt;script src="../js/tools.js" &gt;&lt;/script&gt; &lt;script&gt; var slider = mui("#slider"); var swiperTest = null; var banerArray = new Array(); mui.init(&#123; swipeBack:true //启用右滑关闭功能 &#125;); var slider = mui("#slider"); slider.slider(&#123; interval: 500 &#125;); /**/ mui.plusReady(function() &#123; swiperTest = document.getElementById('swiperTest'); getaData(); &#125;) // 获取数据 function getaData() &#123; var timestamp = getDataStr(); mui.plusReady(function() &#123; mui.ajax(baseUrl, &#123; data: &#123; key: '', typeId: '', showapi_appid: appid, showapi_sign: sign, showapi_timestamp: timestamp, page:1 &#125;, dataType: 'json', type: 'post', timeout: 10000, beforeSend: function(data) &#123; plus.nativeUI.showWaiting(); &#125;, success: function(data) &#123; plus.nativeUI.closeWaiting(); if (data.showapi_res_code == 0) &#123; console.log("成功"); var dice1 = data.showapi_res_body; var dice2 = dice1.pagebean; var swpier = ''; for (var i = 0;i &lt; 5; i ++) &#123; var item = dice2.contentlist[i]; var temp = '&lt;div class="swiper-slide"&gt;&lt;img src=" ' + item.contentImg + '" id="test' + i + '"/&gt;&lt;/div&gt;'; swpier = swpier + temp; banerArray.push(item); &#125; swiperTest.innerHTML = swpier; var mySwiper = new Swiper('.swiper-container', &#123; autoplay: 1000,/*自动播放时间间隔 单位ms*/ pagination : '.swiper-pagination', /*添加分页*/ loop: true, /*开启循环*/ &#125;) /*轮播图页面跳转*/ mui.each(banerArray,function(index,item)&#123; var imgID = 'test' + index; document.getElementById(imgID).addEventListener('tap',function() &#123; mui.openWindow(&#123; url: 'detail.html', id: 'detail', show: &#123; aniShow: 'slide-in-right' /*页面切换效果*/ &#125;, extras: &#123; detailUrl: item.url, detailTitle: item.title &#125;, &#125;); &#125;) &#125;) &#125; &#125;, error: function(xhr, type, errerThrown) &#123; mui.toast('网络异常,请稍候再试'); plus.nativeUI.closeWaiting(); &#125; &#125;); &#125;); &#125; &lt;/script&gt;&lt;/html&gt; 代码方面没有什么好说的，注释都有了，也可以看看Swpier官网和mui的例子。在新的更新代码里面，我把公用的地方放在了一个公共的js文件里面去了，新的代码已经提交我的Github了。欢迎给星星。 三、最后轮播图使用还是不难，但是我觉得我的点击事件的处理还是有问题，但是又不知道哪里有问题，总感觉代码写的不够简洁。其实有了轮播图和表格，做一个简单的阅读类的App再加上一些缓存的使用就可以了。明天回家过六一，呵呵O(∩_∩)O~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(三)表格上拉加载更多下拉刷新]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E4%B8%89)%E8%A1%A8%E6%A0%BC%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%2F</url>
      <content type="text"><![CDATA[一、开始在《Swift 集成Alamofire/Kingfisher/MJRefresh/MBProgressHUD的小项目》利用showAPI上的接口，做了一个上下拉的小Demo。之后就没有什么时间搞Swift了，这个月发表博客的数量也没有上个月多了。这个月使用HBuilder搞WebApp,不管App怎样，也总算是学了一些东西。昨天周日一天没有出门，就自己新建了一个小的WebApp的项目，昨天就把代码敲好了，昨天的第一篇《 HBuilder webApp开发开发(一)新建项目》，但是没时间写第二篇博客，今天下班后就接着写第二篇。关于表格的上下拉，个人感觉没有什么好写的，贴贴代码，以后遇见类似的就这么套就是了。但是在实际使用中还是有些问题：1.真机调试时安卓机的流畅度就没有苹果机的好，2.不知道是否有cell的重用，上拉的时候就在那里一直的appendChild。 二、效果图为什么MarkDown不能设置图片大小呢？ 三、代码请求和样式都在一个html文件里面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;link rel="stylesheet" href="../css/mui.min.css"&gt; &lt;link rel="stylesheet" href="../css/app.css" /&gt; &lt;/head&gt; &lt;style&gt; .head-part &#123; padding-top: 10px; &#125; .head-part #auther &#123; height: 30px; line-height: 30px; margin-left: 70px; &#125; .head-part #currentDate &#123; height: 30px; width: 300px; line-height: 30px; margin-left: 70px; font-size: 14px; &#125; .head-part .about-type &#123; float: right; margin-right: 10px; text-align: right; text-overflow:ellipsis; overflow:hidden; white-space:nowrap; width: 100px; color: red; &#125; #headImage &#123; width: 60px; height: 60px; border-radius: 30px; display: block; position: absolute; float: left; &#125; #titleConcent &#123; height: 110px; &#125; #mainImage &#123; padding-right: 10px; width: 100px; height: 100px; float: right; &#125; #titleConcent1 &#123; margin-top: 10px; height: 100px; text-overflow:ellipsis; overflow:hidden; line-height: 25px; &#125; .mui-scroll .mui-table-view &#123; padding-left: 10px; &#125; .tableView-cell &#123; list-style-type: none; /*设置下边框样式*/ border-bottom-style: solid; border-bottom-width: 1px; border-bottom-color: #D3D3D3; &#125; .mui-content&#123; padding-top: 44px; &#125; .mui-table-view:before&#123; 0px; &#125; .mui-table-view:after&#123; 0px; &#125; &lt;/style&gt; &lt;body style="background-color: #D3D3D3;"&gt; &lt;header class="mui-bar mui-bar-nav black"&gt; &lt;h1 class="mui-title"&gt;消息&lt;/h1&gt; &lt;/header&gt; &lt;div class="mui-content"&gt; &lt;!--下拉刷新容器--&gt; &lt;div id="pullrefresh" class="mui-content mui-scroll-wrapper"&gt; &lt;div class="mui-scroll"&gt; &lt;!--数据列表--&gt; &lt;ul class="mui-table-view" style="background-color: white;"&gt; &lt;li class="tableView-cell"&gt; &lt;!--&lt;div class="head-part"&gt; &lt;img src="../images/shuijiao.jpg"/ id="headImage"&gt; &lt;div class="about-auther"&gt; &lt;div id="auther"&gt; 作者名字&lt;span class="about-type"&gt;印象派印象&lt;/span&gt; &lt;/div&gt; &lt;div id="currentDate"&gt; 2016-05-16 10:22:12 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="titleConcent"&gt; &lt;img src="../images/yuantiao.jpg" id="mainImage"/&gt; &lt;div id="titleConcent1"&gt; 今天是2016.05.16,其实我的内心是奔溃的啊,加班! 今天是2016.05.16,其实我的内心是奔溃的啊,加班! 今天是 &lt;/div&gt; &lt;/div&gt;--&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="../js/mui.js" &gt;&lt;/script&gt; &lt;script type="text/javascript" charset="utf-8"&gt; var pageIndex = 1; // 页数 var allPages = 1; // 总页数 /*showAPI配置参数*/ var appid = "19297" var sign = "56743e56cce6482eb499e0abb79a0c78" var baseUrl = "https://route.showapi.com/582-2?" var table = document.body.querySelector('.mui-table-view'); (function($) &#123; //阻尼系数 感觉在上拉时比较明显 var deceleration = mui.os.ios ? 0.003 : 0.0009; $('.mui-scroll-wrapper').scroll(&#123; bounce: false, indicators: true, //是否显示滚动条 deceleration: deceleration &#125;); &#125;)(mui); mui.init(&#123; pullRefresh: &#123; container: '#pullrefresh', down: &#123; callback: pulldownRefresh &#125;, up: &#123; contentrefresh: '正在加载...', callback: pullupRefresh &#125; &#125; &#125;); /** * 下拉刷新具体业务实现 */ function pulldownRefresh() &#123; pageIndex = 1; console.log('下拉刷新'); //table.innerHTML = ''; setTimeout(function() &#123; getaData(); mui('#pullrefresh').pullRefresh().endPulldownToRefresh(); mui('#pullrefresh').pullRefresh().refresh(true); &#125;, 1000); &#125; /** * 上拉加载具体业务实现 */ function pullupRefresh() &#123; pageIndex = ++pageIndex; console.log(pageIndex); console.log('上拉加载更多'); setTimeout(function() &#123; getaData() &#125;, 1000); &#125; if (mui.os.plus) &#123; mui.plusReady(function() &#123; setTimeout(function() &#123; mui('#pullrefresh').pullRefresh().pulldownLoading(); &#125;, 500); &#125;); &#125; else &#123; mui.ready(function() &#123; mui('#pullrefresh').pullRefresh().pulldownLoading(); &#125;); &#125; // 获取数据 function getaData() &#123; var timestamp = getDataStr(); mui.plusReady(function() &#123; mui.ajax(baseUrl, &#123; data: &#123; key: '', typeId: '', showapi_appid: appid, showapi_sign: sign, showapi_timestamp: timestamp, page:pageIndex &#125;, dataType: 'json', type: 'post', timeout: 10000, beforeSend: function(data) &#123; plus.nativeUI.showWaiting(); &#125;, success: function(data) &#123; plus.nativeUI.closeWaiting(); if (data.showapi_res_code == 0) &#123; console.log("成功"); var dice1 = data.showapi_res_body; var dice2 = dice1.pagebean; var result = ''; if (pageIndex == 1) &#123; //下拉刷新需要先清空数据 table.innerHTML = '';// 在这里清空可以防止刷新时白屏 &#125; allPages = dice2.allPages;/*获取总的分页数*/ /*表格填充数据 mui.each是异步的*/ mui.each(dice2.contentlist, function(index, item) &#123; var li = document.createElement('li'); li.url = item.url; /*详情url*/ li.title = item.title; /*详情标题*/ li.className = 'tableView-cell'; li.innerHTML = '&lt;div class="head-part"&gt;' + '&lt;img src="' + item.userLogo + '"/ id="headImage"&gt;' + '&lt;div class="about-auther"&gt;' + '&lt;div id="auther"&gt;' + item.userName + '&lt;span class="about-type"&gt;' + item.typeName + '&lt;/span&gt;&lt;/div&gt;&lt;div id="currentDate"&gt;' + item.date + '&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="titleConcent"&gt;' + '&lt;img src=" '+ item.contentImg + '" id="mainImage"/&gt;&lt;div id="titleConcent1"&gt;' + item.title + '&lt;/div&gt;&lt;/div&gt;'; table.appendChild(li, table.firstChild); &#125;); if(pageIndex &lt; allPages)&#123; mui('#pullrefresh').pullRefresh().endPullupToRefresh(false); /*能上拉*/ &#125;else&#123; mui('#pullrefresh').pullRefresh().endPullupToRefresh(true);/*不能上拉*/ &#125; &#125; &#125;, error: function(xhr, type, errerThrown) &#123; mui.toast('网络异常,请稍候再试'); plus.nativeUI.closeWaiting(); mui('#pullrefresh').pullRefresh().endPullupToRefresh(true); &#125; &#125;); &#125;); &#125; // 获取当前时间 yyyyMMddHHmmss function getDataStr()&#123; var date = new Date(); var year = date.getFullYear(); var mouth = date.getMonth() + 1; var day = date.getDate(); var hour = date.getHours(); var minute = date.getMinutes(); var second = date.getSeconds(); if(mouth &lt; 10)&#123; /*月份小于10 就在前面加个0*/ mouth = String(String(0) + String(mouth)); &#125; var currentDate = String(year) + String(mouth) + String(day) + String(hour) + String(minute) + String(second); return currentDate; &#125; //链接批量处理 页面跳转 var aniShow = "pop-in"; mui('.mui-content').on('tap', 'li', function() &#123; console.log("detail-url -- &gt;&gt; " + this.url); console.log("detail-title -- &gt;&gt; " + this.title); mui.openWindow(&#123; url: 'detail.html', id: 'detail', show: &#123; duration: 200, &#125;, waiting: &#123; autoShow: true &#125;, extras: &#123; detailUrl: this.url, detailTitle: this.title &#125;, &#125;); &#125;); &lt;/script&gt;&lt;/html&gt; 四、思路代码里面有注释，大致思路：1.做一个刷新的容器；2.加上一个可以上下滑动的scroll；3.创建table;4.创建cell；5.等把cell的样式做好了就就可以把cell的代码注释掉，然后在请求回来数据的时候再写一次，只是这次是使用的网络数据。 五、关于上下拉关于上下拉，其实也就是一些固定的思路，之前在写原生的iOS表格上下拉的时候基本也是一些固定的思路和方法。上下拉的思路和方法，可以看看《HTML5 WebApp开发(一)新建项目》提到的模板项目的目录examples/pullrefresh_sub.html这个html文件，只是这里我们使用的网路数据。 六、注意点1.在下拉刷新的时候我们需要先清空使用table.innerHTML = ‘’清空一下表格。关于在什么时候调用清空的方法，在代码里面有说明；2.分页的处理，分页的处理基本和原生iOS开发时一样，无非就是判断当前页码是否是最后一页，最后一页的时候就不可以上拉了； 七、提高点页面数据需要做缓存，在没有网络的时候，如果没有缓存，那么这个页面就空白的，这样的用户体验并不好。关于加缓存的问题，等有时间继续写这个代码的时候在来加。 八、最后代码下载地址：请点击我！ 九、更新日志 2016-05-24 关于缓存的问题，在《提升HTML5的性能体验系列之一 避免切页白屏》，HBuilder提供了一些优化的方法，这些方法和数据缓存有些关系，但是我有我自己的想法，实际操作也是可行的。声明一个全局变量例如revData（revData也可以使用其他方法永久存储起来），用来接收从服务器获取的数据。在显示的时候，我们做一个判断，当revData数据不为空的时候，我们就从revData解析数据显示，revData为空的时候我们就显示当前从网络获取的数据，由于初始是revData是空的所以第一次显示的是网络获取的数据，之后显示的是上次从网络获取的数据revData。为什么之后使用revData做显示时，图片可以显示出来呢？这是HBuilder帮我们把图片做了缓存处理，就像SDWebImage，我们只需要知道图片的url就可以从缓存中取到图片数据。但是使用只使用revData来缓存数据是存在问题的。如果在下次进入页面的时候，数据更新了怎么办？这个时候我们可以在服务器返回的json数据里面增加一个字段了如：update。当update=1时，表示数据发生了变化，这个时候我们就使用这次从网络获取的数据显示，当update=0，时，我们就使用上一次从服务器获取的数据revData去显示。对于图片数据和返回的json数据流来说，返回的json数据的数据量是很小的。 1234567891011function showUpdate()&#123; if (update == 1) &#123; /*服务器有更新数据或者第一次请求update=1*/ // 显示网路数据 &#125; else&#123; /*服务器没有数据更新*/ if (revData == null) &#123; /*没有缓存*/ // 显示网络数据 &#125; else&#123; /*有缓存*/ //显示缓存数据 &#125; &#125; &#125; 但是这样就又存在一个问题，服务器怎么知道前端是第几次请求数据呢，或者说第一次请求时update是多少。由于没做过页面缓存相关的，所以不知道怎么解这个问题。是否可以在接口里面增加终端设备的硬件参数呢？感觉这种做法是可以的。代码已经同步到了我的github了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(二) Websql增删改查操作]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E4%BA%8C)%20Websql%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[这段时间公司要求我们做原生iOS和安卓的都转做H5开发APP,使用的工具HBuilder。公司这么要求我们也就只能转行做了。大家都是小白，好在公司有两位H5大神，他们先给我们一些代码看看，所以，我们上手也比较快。在做APP的过程中用到了一些本地存储，关于本地存储大家可以看看《App离线本地存储方案》 。里面我只说说Web SQL,因为里面的localstorage，plus.storage和websql都是我使用过的，其中localstorage和plus.storage是以键值对的形式存储，操作比较简单，但是websql操作数据库就有点不一样了，这个我也是搞了一天才调试好。在使用HBuilder的过程中，感觉最坑爹的是有时错了都不知道错在哪里了，又不能断点调试，但是有点好的是做界面的时候可以边改边看。出现问题就只能自己慢慢的找了。还好，代码写了 一段时间就有一些调试技巧，写代码的错误率也降低了。 一、界面 二、数据库的操作增删改查基本就是我们操作数据库的四个最基本的操作了。界面按钮的操作步骤：新建数据库–&gt;插入数据–&gt;查找一条数据–&gt;修改数据–&gt;查找一条数据–&gt;查找全部数据–&gt;删除一条数据–&gt;删除全部数据。 1234567891011121314151617181920212223242526272829303132[LOG] : 新建数据库 [LOG] : 插入数据[LOG] : 插入websqlTable小明成功[LOG] : 插入websqlTable小红成功[LOG] : 插入websqlTable小强成功[LOG] : 查找一条数据[LOG] : NAME = 小明[LOG] : AGE = 18[LOG] : HEIGHT = 175cm[LOG] : WEIGTH = 60kg[LOG] : 修改数据[LOG] : 查找一条数据[LOG] : NAME = 小明[LOG] : AGE = 1000 /*修改之后的结果*/[LOG] : HEIGHT = 175cm[LOG] : WEIGTH = 60kg[LOG] : 查找全部数据[LOG] : NAME = 小明[LOG] : AGE = 1000[LOG] : HEIGHT = 175cm[LOG] : WEIGTH = 60kg[LOG] : -------- 我是分割线 -------[LOG] : NAME = 小红[LOG] : AGE = 17[LOG] : HEIGHT = 160cm[LOG] : WEIGTH = 45kg[LOG] : -------- 我是分割线 -------[LOG] : NAME = 小强[LOG] : AGE = 19[LOG] : HEIGHT = 185cm[LOG] : WEIGTH = 70kg[LOG] : -------- 我是分割线 ------- websql.js文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/***数据库操作辅助类,定义对象、数据操作方法都在这里定义*/var dbname='websql';/*数据库名*/var version = '1.0'; /*数据库版本*/var dbdesc = 'websql练习'; /*数据库描述*/var dbsize = 2*1024*1024; /*数据库大小*/var dataBase = null; /*暂存数据库对象*//*数据库中的表单名*/var websqlTable = "websqlTable";/** * 打开数据库 * @returns dataBase:打开成功 null:打开失败 */function websqlOpenDB()&#123; /*数据库有就打开 没有就创建*/ dataBase = window.openDatabase(dbname, version, dbdesc, dbsize,function() &#123;&#125;); if (dataBase) &#123; alert("数据库创建/打开成功!"); &#125; else&#123; alert("数据库创建/打开失败！"); &#125; return dataBase;&#125;/** * 新建数据库里面的表单 * @param tableName:表单名 */function websqlCreatTable(tableName)&#123;// chinaAreaOpenDB(); var creatTableSQL = 'CREATE TABLE IF NOT EXISTS '+ tableName + ' (rowid INTEGER PRIMARY KEY AUTOINCREMENT, NAME text,AGE text,HEIGHT text,WEIGTH text)'; dataBase.transaction(function (ctx,result) &#123; ctx.executeSql(creatTableSQL,[],function(ctx,result)&#123; alert("表创建成功 " + tableName); &#125;,function(tx, error)&#123; alert('创建表失败:' + tableName + error.message); &#125;); &#125;);&#125;/** * 往表单里面插入数据 * @param tableName:表单名 * @param NAME:姓名 * @param AGE:年龄 * @param HEIGHT:身高 * @param WEIGTH:体重 */function websqlInsterDataToTable(tableName,NAME,AGE,HEIGHT,WEIGTH)&#123; var insterTableSQL = 'INSERT INTO ' + tableName + ' (NAME,AGE,HEIGHT,WEIGTH) VALUES (?,?,?,?)'; dataBase.transaction(function (ctx) &#123; ctx.executeSql(insterTableSQL,[NAME,AGE,HEIGHT,WEIGTH],function (ctx,result)&#123; console.log("插入" + tableName + NAME + "成功"); &#125;, function (tx, error) &#123; alert('插入失败: ' + error.message); &#125;); &#125;);&#125;/** * 获取数据库一个表单里面的所有数据 * @param tableName:表单名 * 返回数据集合 */function websqlGetAllData(tableName)&#123; var selectALLSQL = 'SELECT * FROM ' + tableName; dataBase.transaction(function (ctx) &#123; ctx.executeSql(selectALLSQL,[],function (ctx,result)&#123; alert('查询成功: ' + tableName + result.rows.length); var len = result.rows.length; for(var i = 0;i &lt; len;i++) &#123; console.log("NAME = " + result.rows.item(i).NAME); console.log("AGE = " + result.rows.item(i).AGE); console.log("HEIGHT = " + result.rows.item(i).HEIGHT); console.log("WEIGTH = " + result.rows.item(i).WEIGTH); console.log("-------- 我是分割线 -------"); &#125; &#125;, function (tx, error) &#123; alert('查询失败: ' + error.message); &#125;); &#125;);&#125;/** * 获取数据库一个表单里面的部分数据 * @param tableName:表单名 * @param name:姓名 */function websqlGetAData(tableName,name)&#123; var selectSQL = 'SELECT * FROM ' + tableName + ' WHERE NAME = ?' dataBase.transaction(function (ctx) &#123; ctx.executeSql(selectSQL,[name],function (ctx,result)&#123; alert('查询成功: ' + tableName + result.rows.length); var len = result.rows.length; for(var i = 0;i &lt; len;i++) &#123; console.log("NAME = " + result.rows.item(i).NAME); console.log("AGE = " + result.rows.item(i).AGE); console.log("HEIGHT = " + result.rows.item(i).HEIGHT); console.log("WEIGTH = " + result.rows.item(i).WEIGTH); &#125; &#125;, function (tx, error) &#123; alert('查询失败: ' + error.message); &#125;); &#125;);&#125;/** * 删除表单里的全部数据 * @param tableName:表单名 */function websqlDeleteAllDataFromTable(tableName)&#123; var deleteTableSQL = 'DELETE FROM ' + tableName; localStorage.removeItem(tableName); dataBase.transaction(function (ctx,result) &#123; ctx.executeSql(deleteTableSQL,[],function(ctx,result)&#123; alert("删除表成功 " + tableName); &#125;,function(tx, error)&#123; alert('删除表失败:' + tableName + error.message); &#125;); &#125;);&#125;/** * 根据name删除数据 * @param tableName:表单名 * @param name:数据的姓名 */function websqlDeleteADataFromTable(tableName,name)&#123; var deleteDataSQL = 'DELETE FROM ' + tableName + ' WHERE NAME = ?'; localStorage.removeItem(tableName); dataBase.transaction(function (ctx,result) &#123; ctx.executeSql(deleteDataSQL,[name],function(ctx,result)&#123; alert("删除成功 " + tableName + name); &#125;,function(tx, error)&#123; alert('删除失败:' + tableName + name + error.message); &#125;); &#125;);&#125;/** * 根据name修改数据 * @param tableName:表单名 * @param name:姓名 * @param age:年龄 */function websqlUpdateAData(tableName,name,age)&#123; var updateDataSQL = 'UPDATE ' + tableName + ' SET AGE = ? WHERE NAME = ?'; dataBase.transaction(function (ctx,result) &#123; ctx.executeSql(updateDataSQL,[age,name],function(ctx,result)&#123; alert("更新成功 " + tableName + name); &#125;,function(tx, error)&#123; alert('更新失败:' + tableName + name + error.message); &#125;); &#125;);&#125; html文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="../../js/websql.js" &gt;&lt;/script&gt; &lt;/head&gt; &lt;script&gt; function creatTable() &#123; console.log("新建数据库"); websqlOpenDB(); websqlCreatTable(websqlTable); &#125; function insterData() &#123; console.log("插入数据"); websqlInsterDataToTable(websqlTable,"小明","18","175cm","60kg"); websqlInsterDataToTable(websqlTable,"小红","17","160cm","45kg"); websqlInsterDataToTable(websqlTable,"小强","19","185cm","70kg"); &#125; function updateData() &#123; console.log("修改数据"); websqlUpdateAData(websqlTable,"小明","1000") &#125; function deleteAData() &#123; console.log("删除一条数据"); websqlDeleteADataFromTable(websqlTable,"小明"); &#125; function deleteAllData() &#123; console.log("删除全部数据"); websqlDeleteAllDataFromTable(websqlTable); &#125; function selectAData() &#123; console.log("查找一条数据"); websqlGetAData(websqlTable,"小明"); &#125; function selectALlData() &#123; console.log("查找全部数据"); websqlGetAllData(websqlTable); &#125; &lt;/script&gt; &lt;style&gt; .content &#123; padding-top: 50px; &#125; .websql &#123; margin-top: 10px; &#125; /*设置按钮样式*/ .websql button&#123; height: 44px; width: 120px; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class="content"&gt; &lt;div class="websql"&gt; &lt;button type="button" onclick="creatTable()"&gt;新建数据库&lt;/button&gt; &lt;/div&gt; &lt;div class="websql"&gt; &lt;!--增--&gt; &lt;button type="button" onclick="insterData()"&gt;插入数据&lt;/button&gt; &lt;/div&gt; &lt;div class="websql"&gt; &lt;!--删--&gt; &lt;button type="button" onclick="deleteAData()"&gt;删除一条数据&lt;/button&gt; &lt;button type="button" onclick="deleteAllData()"&gt;删除全部数据&lt;/button&gt; &lt;/div&gt; &lt;div class="websql"&gt; &lt;!--改--&gt; &lt;button type="button" onclick="updateData()"&gt;修改数据&lt;/button&gt; &lt;/div&gt; &lt;div class="websql"&gt; &lt;!--查--&gt; &lt;button type="button" onclick="selectAData()"&gt;查找一条数据&lt;/button&gt; &lt;button type="button" onclick="selectALlData()"&gt;查找全部数据&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 三、总结在使用websql的时候，就是操作数据库sql的操作，操作的sql语句也是一样的。前后接触过CoreDate,FMDB,sqlite3和websql，使用的sql语句都是一样的，只是不同的平台和封装导致具体的使用有些不一致。《【iOS】一种仿京东搜索历史记录的表格的实现(sqlite3的使用)》这里有操作CoreDate,FMDB,sqlite3的介绍。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HBuilder webApp开发(一)新建项目]]></title>
      <url>%2F2017%2F01%2F18%2FHBuilder%20webApp%E5%BC%80%E5%8F%91(%E4%B8%80)%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[一、关于HBuilder去DCloud官网下载最新的Hbuilder关于Hbuilder的介绍可以去官网看看。 二、新建移动App 打开HBuilder新建移动App项目文件–&gt;新建–&gt;移动App 勾选mui项目应用名HbuildTest 新建template和images目录 新建5个子页面效果图 页面结构 三、添加子页面在index.html文件中添加如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href="css/mui.min.css" /&gt; &lt;link rel="stylesheet" href="css/app.css" /&gt; //mui.min.css和app.css是Hbuilder提供的两个css文件，每个html文件中都需要包含进来 &lt;style&gt; html, body &#123; background-color: #efeff4; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class="mui-bar mui-bar-tab"&gt; &lt;a id="defaultTab" class="mui-tab-item mui-active" href="template/about.html"&gt; &lt;span class="mui-icon mui-icon-home"&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;首页&lt;/span&gt; &lt;/a&gt; &lt;a class="mui-tab-item" href="template/chat.html"&gt; &lt;span class="mui-icon mui-icon-email"&gt;&lt;span class="mui-badge"&gt;5&lt;/span&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;消息&lt;/span&gt; &lt;/a&gt; &lt;a class="mui-tab-item" href="template/contact.html"&gt; &lt;span class="mui-icon mui-icon-contact"&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;通讯录&lt;/span&gt; &lt;/a&gt; &lt;a class="mui-tab-item" href="template/setting.html"&gt; &lt;span class="mui-icon mui-icon-gear"&gt;&lt;/span&gt; &lt;span class="mui-tab-label"&gt;设置&lt;/span&gt; &lt;/a&gt; &lt;/nav&gt; &lt;script src="js/mui.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" charset="utf-8"&gt; //mui初始化 mui.init(); var subpages = ['template/about.html','template/chat.html', 'template/contact.html', 'template/setting.html']; var subpage_style = &#123; top: '0px', bottom: '51px' &#125;; var aniShow = &#123;&#125;; //创建子页面，首个选项卡页面显示，其它均隐藏； mui.plusReady(function() &#123; var self = plus.webview.currentWebview(); for (var i = 0; i &lt; 4; i++) &#123; var temp = &#123;&#125;; var sub = plus.webview.create(subpages[i], subpages[i], subpage_style); if (i &gt; 0) &#123; sub.hide(); &#125;else&#123; temp[subpages[i]] = "true"; mui.extend(aniShow,temp); &#125; self.append(sub); &#125; &#125;); //当前激活选项 var activeTab = subpages[0]; var title = document.getElementById("title"); //选项卡点击事件 mui('.mui-bar-tab').on('tap', 'a', function(e) &#123; var targetTab = this.getAttribute('href'); if (targetTab == activeTab) &#123; return; &#125; //更换标题// title.innerHTML = this.querySelector('.mui-tab-label').innerHTML; //显示目标选项卡 //若为iOS平台或非首次显示，则直接显示 if(mui.os.ios||aniShow[targetTab])&#123; plus.webview.show(targetTab); &#125;else&#123; //否则，使用fade-in动画，且保存变量 var temp = &#123;&#125;; temp[targetTab] = "true"; mui.extend(aniShow,temp); plus.webview.show(targetTab,"fade-in",300); &#125; //隐藏当前; plus.webview.hide(activeTab); //更改当前活跃的选项卡 activeTab = targetTab; &#125;); //自定义事件，模拟点击“首页选项卡” document.addEventListener('gohome', function() &#123; var defaultTab = document.getElementById("defaultTab"); //模拟首页点击 mui.trigger(defaultTab, 'tap'); //切换选项卡高亮 var current = document.querySelector(".mui-bar-tab&gt;.mui-tab-item.mui-active"); if (defaultTab !== current) &#123; current.classList.remove('mui-active'); defaultTab.classList.add('mui-active'); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 四、效果图：和原生的一样，底部的tabBar最多只能放5个，多了就会显示… 五、为什么这么写在目录examples/tab-webview-main.html里面找到这个tab-webview-main.html文件，接下来我们按照这个页面的html文件里面的代码样式新建4个子页面about.html,chat.html, contact.html, setting.html。就有了上面的项目目录结构。在就是按照模板修改，把文件替换为我新建的html文件。就有了上面的代码了。至此项目的基本结构就新建完成了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下express的安装和新建项目]]></title>
      <url>%2F2017%2F01%2F13%2FMac%E4%B8%8Bexpress%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[在《Mac下安装Node.js、测试、输出json》我的电脑已经安装了node.js。 一、安装express打开终端1.需先安装express-generator1npm install -g express-generator 2.安装express1npm install -g express 3.验证是否安装成功1express --version 二、新建项目还是打开终端1.新建ejs模板，(还有jade模板，请自行百度怎么新建)1express --view=ejs Express 1--view=ejs 表示新建的ejs模板的项目，Express是项目名字这时效果如下：123456789101112131415161718192021222324252627Last login: Fri Jan 13 13:38:16 on ttys000hgdqdeMacBook-Pro:~ hgdq$ express --view=ejs Express create : Express create : Express/package.json create : Express/app.js create : Express/public create : Express/public/images create : Express/public/stylesheets create : Express/public/stylesheets/style.css create : Express/routes create : Express/routes/index.js create : Express/routes/users.js create : Express/views create : Express/views/index.ejs create : Express/views/error.ejs create : Express/bin create : Express/bin/www install dependencies: $ cd Express &amp;&amp; npm install run the app: $ DEBUG=express:* npm start create : Express/public/javascriptshgdqdeMacBook-Pro:~ hgdq$ 2.下面已经提示了我们要先cd到项目目录和安装依赖1cd Express &amp;&amp; npm install 3.启动项目:1npm start 4.浏览器查看1http://localhost:3000 这里的localhost可以是你的IP地址。看见上面这个图就表示已经成功了。 三、项目目录打开Express/bin目录下面的www.js文件文件你就会知道为什么在浏览器输入http://localhost:3000就可以查看了。 四、express官网express官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下安装Node.js、测试、输出json]]></title>
      <url>%2F2017%2F01%2F12%2FMac%E4%B8%8B%E5%AE%89%E8%A3%85Node.js%E3%80%81%E6%B5%8B%E8%AF%95%E3%80%81%E8%BE%93%E5%87%BAjson%2F</url>
      <content type="text"><![CDATA[一、什么是node.js关于这个百度百科会有专业解释：node.js 二、Node.js的安装关于Node.js的安装大家可以去菜鸟教程查看–Node.js 安装配置安装完成之后,我们可以在终端输入1node -v 查看，如果安装正确，这时就会打印node.js的版本。至此表示你的node.js已经安装正确。 三、测试1.我们新建一个js文件，输入以下代码：123456789101112// 添加依赖模块var http = require('http');http.createServer(function (request, response) &#123;// 发送 HTTP 头部 // HTTP 状态值: 200 : OK// 内容类型: text/plainresponse.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;);// 发送响应数据 "Hello World"response.end('Hello World\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 2.然后在终端cd到js文件所在目录，执行1node test.js test是你的js文件名。效果如图： 四、输出json各式的数据通常我们在左app的时候，前后端是通过接口对接的，数据各式一般都是json各式,其实node.js也可以返回json各式的数据。这里我们只需要修改上面的代码即可：12345678910111213// 添加依赖模块var http = require('http');http.createServer(function (request, response) &#123;// 发送 HTTP 头部 // HTTP 状态值: 200 : OK// 内容类型: application/json// 字符编码：charset=utf-8 解决返回的json数据里面的中文乱码response.writeHead(200, &#123;'Content-Type': 'application/json;charset=utf-8'&#125;);// 发送响应json数据response.end(JSON.stringify(&#123;name:'湖工电气',value:'测试的json数据'&#125;));&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 输出效果如下：最后，node.js我们也安装了，也测试了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
